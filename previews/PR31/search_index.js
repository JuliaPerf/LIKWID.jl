var documenterSearchIndex = {"docs":
[{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"using LIKWID","category":"page"},{"location":"power/#Power-/-Energy","page":"Power / Energy","title":"Power / Energy","text":"","category":"section"},{"location":"power/#Example","page":"Power / Energy","title":"Example","text":"","category":"section"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"General power information:","category":"page"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"power = LIKWID.Power.get_power_info()\npower.domains\nfirst(power.domains)","category":"page"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"Energy measurement:","category":"page"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"LIKWID.Power.measure(; cpuid=0, domainid=0) do\n    sleep(1)\nend\nLIKWID.Power.measure(; cpuid=0, domainid=0) do\n    sum(sin(rand()) for _ in 1:1_000_000)\nend","category":"page"},{"location":"power/#API","page":"Power / Energy","title":"API","text":"","category":"section"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"Pages   = [\"power.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"power/#Functions","page":"Power / Energy","title":"Functions","text":"","category":"section"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"LIKWID.Power.init\nLIKWID.Power.finalize\nLIKWID.Power.get_power_info\nLIKWID.Power.start_power\nLIKWID.Power.stop_power\nLIKWID.Power.get_power\nLIKWID.Power.measure","category":"page"},{"location":"power/#LIKWID.Power.init","page":"Power / Energy","title":"LIKWID.Power.init","text":"Initialize power measurements for the given CPU. Returns the RAPL status, i.e. false (no RAPL) or true (RAPL working).\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.finalize","page":"Power / Energy","title":"LIKWID.Power.finalize","text":"Finalize power measurements.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.get_power_info","page":"Power / Energy","title":"LIKWID.Power.get_power_info","text":"get_power_info() -> LIKWID.PowerInfo\n\nGet power / energy information.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.start_power","page":"Power / Energy","title":"LIKWID.Power.start_power","text":"Return the start value for a cpu (cpuid) for the domain with domainid.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.stop_power","page":"Power / Energy","title":"LIKWID.Power.stop_power","text":"Return the stop value for a cpu (cpuid) for the domain with domainid.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.get_power","page":"Power / Energy","title":"LIKWID.Power.get_power","text":"get_power(p_start::Integer, p_stop::Integer, domainid::Integer)\n\nCalculate the μJ from the values retrieved by start_power() and stop_power().\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.measure","page":"Power / Energy","title":"LIKWID.Power.measure","text":"measure(f; cpuid::Integer=0, domainid::Integer)\n\nMeasure / calculate the energy for the given cpuid and domainid over the execution of the function f using Power.start_power, Power.stop_power, etc. under the hood. Automatically initializes and finalizes the power module.\n\nExamples\n\njulia> LIKWID.Power.measure(; cpuid=0, domainid=0) do\n           sleep(1)\n       end\n15.13702392578125 μJ\n\n\n\n\n\n","category":"function"},{"location":"power/#Types","page":"Power / Energy","title":"Types","text":"","category":"section"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"LIKWID.PowerInfo\nLIKWID.PowerDomain\nLIKWID.LibLikwid.PowerType\nLIKWID.TurboBoost","category":"page"},{"location":"power/#LIKWID.PowerInfo","page":"Power / Energy","title":"LIKWID.PowerInfo","text":"Power information\n\n\n\n\n\n","category":"type"},{"location":"power/#LIKWID.PowerDomain","page":"Power / Energy","title":"LIKWID.PowerDomain","text":"Power domain information\n\n\n\n\n\n","category":"type"},{"location":"power/#LIKWID.LibLikwid.PowerType","page":"Power / Energy","title":"LIKWID.LibLikwid.PowerType","text":"Different types of power domains\n\n\n\n\n\n","category":"type"},{"location":"power/#LIKWID.TurboBoost","page":"Power / Energy","title":"LIKWID.TurboBoost","text":"Turbo boost information\n\n\n\n\n\n","category":"type"},{"location":"examples/saxpy/#Using-the-Marker-API","page":"Using the Marker API","title":"Using the Marker API","text":"","category":"section"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"Below we showcase how to use LIKWIDs Marker API to monitor hardware performance counters for simple SAXPY operations (\"single precision a times x plus y\" for vectors x,y and scalar a) executed on CPU, CPU+GPU, and multiple (CPU) threads. For more detailed information about the API see Marker API (CPU) and Marker API (GPU).","category":"page"},{"location":"examples/saxpy/#saxpy_cpu","page":"Using the Marker API","title":"CPU","text":"","category":"section"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"Example that demonstrates using the CPU Marker API.","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"# saxpy_cpu.jl\nusing LIKWID\nusing LinearAlgebra\n\nN = 100_000_000\na = 3.141f0\nz = zeros(Float32, N)\nx = rand(Float32, N)\ny = rand(Float32, N)\n\nfunction saxpy_cpu!(z,a,x,y)\n    z .= a .* x .+ y\nend\n\nMarker.init()\n\nsaxpy_cpu!(z,a,x,y)\n@region \"saxpy_cpu\" saxpy_cpu!(z,a,x,y)\n\nMarker.close()","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"Output of likwid-perfctr -C 0 -g FLOPS_SP -m julia saxpy_cpu.jl:","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6148 CPU @ 2.40GHz\nCPU type:\tIntel Skylake SP processor\nCPU clock:\t2.39 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion saxpy_cpu, Group 1: FLOPS_SP\n+-------------------+------------+\n|    Region Info    | HWThread 0 |\n+-------------------+------------+\n| RDTSC Runtime [s] |   0.097326 |\n|     call count    |          1 |\n+-------------------+------------+\n\n+------------------------------------------+---------+------------+\n|                   Event                  | Counter | HWThread 0 |\n+------------------------------------------+---------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  |   10850760 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  |   69311210 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  |          0 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_SINGLE |   PMC0  |          0 |\n|    FP_ARITH_INST_RETIRED_SCALAR_SINGLE   |   PMC1  |        111 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_SINGLE |   PMC2  |    4805495 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_SINGLE |   PMC3  |          0 |\n+------------------------------------------+---------+------------+\n\n+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.0973 |\n| Runtime unhalted [s] |     0.0289 |\n|      Clock [MHz]     |     inf    |\n|          CPI         |     6.3877 |\n|     SP [MFLOP/s]     |   395.0039 |\n|   AVX SP [MFLOP/s]   |   395.0028 |\n|  AVX512 SP [MFLOP/s] |          0 |\n|   Packed [MUOPS/s]   |    49.3753 |\n|   Scalar [MUOPS/s]   |     0.0011 |\n|  Vectorization ratio |    99.9977 |\n+----------------------+------------+","category":"page"},{"location":"examples/saxpy/#saxpy_cpugpu","page":"Using the Marker API","title":"CPU+GPU","text":"","category":"section"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"Example that demonstrates using the CPU and GPU Marker API together in one application.","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"# saxpy.jl\nusing LIKWID\nusing CUDA\nusing LinearAlgebra\n\n@assert CUDA.functional()\n\nN = 100_000_000\na = 3.141f0\nz = zeros(Float32, N)\nx = rand(Float32, N)\ny = rand(Float32, N)\n\nz_gpu = CUDA.zeros(Float32, N)\nx_gpu = CUDA.rand(Float32, N)\ny_gpu = CUDA.rand(Float32, N)\n\nfunction saxpy_cpu!(z,a,x,y)\n    z .= a .* x .+ y\nend\n\nfunction saxpy_gpu!(z,a,x,y)\n    CUDA.@sync z .= a .* x .+ y\nend\n\nMarker.init()\nGPUMarker.init()\n\nsaxpy_cpu!(z,a,x,y)\n@region \"saxpy_cpu\" saxpy_cpu!(z,a,x,y)\n\nsaxpy_gpu!(z_gpu,a,x_gpu,y_gpu)\n@gpuregion \"saxpy_gpu\" saxpy_gpu!(z_gpu,a,x_gpu,y_gpu)\n\nMarker.close()\nGPUMarker.close()","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"Output of likwid-perfctr -C 0 -g FLOPS_SP -G 0 -W FLOPS_SP -m julia saxpy.jl:","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6246 CPU @ 3.30GHz\nCPU type:\tIntel Cascadelake SP processor\nCPU clock:\t3.30 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion saxpy_cpu, Group 1: FLOPS_SP\n+-------------------+------------+\n|    Region Info    | HWThread 0 |\n+-------------------+------------+\n| RDTSC Runtime [s] |   0.090796 |\n|     call count    |          1 |\n+-------------------+------------+\n+------------------------------------------+---------+------------+\n|                   Event                  | Counter | HWThread 0 |\n+------------------------------------------+---------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  |   59866700 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  |  344927500 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  |  298780700 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_SINGLE |   PMC0  |          0 |\n|    FP_ARITH_INST_RETIRED_SCALAR_SINGLE   |   PMC1  |        111 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_SINGLE |   PMC2  |   25000000 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_SINGLE |   PMC3  |          0 |\n+------------------------------------------+---------+------------+\n+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.0908 |\n| Runtime unhalted [s] |     0.1045 |\n|      Clock [MHz]     |  3809.5859 |\n|          CPI         |     5.7616 |\n|     SP [MFLOP/s]     |  2202.7354 |\n|   AVX SP [MFLOP/s]   |  2202.7341 |\n|  AVX512 SP [MFLOP/s] |          0 |\n|   Packed [MUOPS/s]   |   275.3418 |\n|   Scalar [MUOPS/s]   |     0.0012 |\n|  Vectorization ratio |    99.9996 |\n+----------------------+------------+\nRegion saxpy_gpu, Group 1: FLOPS_SP\n+-------------------+----------+\n|    Region Info    |   GPU 0  |\n+-------------------+----------+\n| RDTSC Runtime [s] | 0.010824 |\n|     call count    |        1 |\n+-------------------+----------+\n+----------------------------------------------------+---------+-----------+\n|                        Event                       | Counter |   GPU 0   |\n+----------------------------------------------------+---------+-----------+\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FADD_PRED_ON_SUM |   GPU0  |         0 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FMUL_PRED_ON_SUM |   GPU1  |         0 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FFMA_PRED_ON_SUM |   GPU2  | 100000000 |\n+----------------------------------------------------+---------+-----------+\n+---------------------+------------+\n|        Metric       |    GPU 0   |\n+---------------------+------------+\n| Runtime (RDTSC) [s] |     0.0108 |\n|     SP [MFLOP/s]    | 18477.1502 |\n+---------------------+------------+","category":"page"},{"location":"examples/saxpy/#saxpy_threads","page":"Using the Marker API","title":"Multithreading","text":"","category":"section"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"warning: Warning\nIt is crucial that you pin the Julia threads reliably to the cores that we are monitoring with LIKWID. Here, we will use likwid-pin with an appropriate pinmask but, in general, it might be easier to use JULIA_EXCLUSIVE=1 or ThreadPinning.jl.","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"# saxpy_threads.jl\nusing LIKWID\nusing LinearAlgebra\nusing Base.Threads: nthreads, @threads\n\n@assert nthreads() > 1 # multithreading\n\n# Julia threads should be pinned!\n@threads :static for tid in 1:nthreads()\n    core = LIKWID.get_processor_id()\n    println(\"Thread $tid, Core $core\")\nend\n\nN = 100_000_000\na = 3.141f0\nzs = [zeros(Float32, N) for _ in 1:nthreads()]\nx = rand(Float32, N)\ny = rand(Float32, N)\n\nfunction saxpy_cpu!(z, a, x, y)\n    z .= a .* x .+ y\nend\n\nfunction saxpy_threads(zs, a, x, y)\n    @threads :static for tid in 1:nthreads()\n        @region \"saxpy_cpu!\" saxpy_cpu!(zs[tid], a, x, y)\n    end\nend\n\nMarker.init()\n\nsaxpy_cpu!(zs[1], a, x, y) # precompile saxpy_cpu\nsaxpy_threads(zs, a, x, y)\n\nMarker.close()","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"Output for likwid-perfctr -c 0-2 -g FLOPS_SP -m likwid-pin -s 0xfffffffffffffff1 -c 0-2 julia --project=. -t3 threads.jl:","category":"page"},{"location":"examples/saxpy/","page":"Using the Marker API","title":"Using the Marker API","text":"Warning: The Marker API requires the application to run on the selected CPUs.\nWarning: likwid-perfctr pins the application only when using the -C command line option.\nWarning: LIKWID assumes that the application does it before the first instrumented code region is started.\nWarning: You can use the string in the environment variable LIKWID_THREADS to pin you application to\nWarning: to the CPUs specified after the -c command line option.\n--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6246 CPU @ 3.30GHz\nCPU type:\tIntel Cascadelake SP processor\nCPU clock:\t3.30 GHz\n--------------------------------------------------------------------------------\nThread 2, Core 1\nThread 3, Core 2\nThread 1, Core 0\n--------------------------------------------------------------------------------\nRegion saxpy_cpu!, Group 1: FLOPS_SP\n+-------------------+------------+------------+------------+\n|    Region Info    | HWThread 0 | HWThread 1 | HWThread 2 |\n+-------------------+------------+------------+------------+\n| RDTSC Runtime [s] |   0.146394 |   0.199333 |   0.178488 |\n|     call count    |          1 |          1 |          1 |\n+-------------------+------------+------------+------------+\n+------------------------------------------+---------+------------+------------+------------+\n|                   Event                  | Counter | HWThread 0 | HWThread 1 | HWThread 2 |\n+------------------------------------------+---------+------------+------------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  |   46977220 |   47074720 |   47030020 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  |  383841400 |  399093000 |  382726500 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  |  343281800 |  403328100 |  386764600 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_SINGLE |   PMC0  |          0 |          0 |          0 |\n|    FP_ARITH_INST_RETIRED_SCALAR_SINGLE   |   PMC1  |          0 |          0 |          0 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_SINGLE |   PMC2  |   25000000 |   25000000 |   25000000 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_SINGLE |   PMC3  |          0 |          0 |          0 |\n+------------------------------------------+---------+------------+------------+------------+\n+-----------------------------------------------+---------+------------+-----------+-----------+--------------+\n|                     Event                     | Counter |     Sum    |    Min    |    Max    |      Avg     |\n+-----------------------------------------------+---------+------------+-----------+-----------+--------------+\n|             INSTR_RETIRED_ANY STAT            |  FIXC0  |  141081960 |  46977220 |  47074720 |     47027320 |\n|           CPU_CLK_UNHALTED_CORE STAT          |  FIXC1  | 1165660900 | 382726500 | 399093000 | 3.885536e+08 |\n|           CPU_CLK_UNHALTED_REF STAT           |  FIXC2  | 1133374500 | 343281800 | 403328100 |    377791500 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_SINGLE STAT |   PMC0  |          0 |         0 |         0 |            0 |\n|    FP_ARITH_INST_RETIRED_SCALAR_SINGLE STAT   |   PMC1  |          0 |         0 |         0 |            0 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_SINGLE STAT |   PMC2  |   75000000 |  25000000 |  25000000 |     25000000 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_SINGLE STAT |   PMC3  |          0 |         0 |         0 |            0 |\n+-----------------------------------------------+---------+------------+-----------+-----------+--------------+\n+----------------------+------------+------------+------------+\n|        Metric        | HWThread 0 | HWThread 1 | HWThread 2 |\n+----------------------+------------+------------+------------+\n|  Runtime (RDTSC) [s] |     0.1464 |     0.1993 |     0.1785 |\n| Runtime unhalted [s] |     0.1163 |     0.1209 |     0.1160 |\n|      Clock [MHz]     |  3689.9336 |  3265.3756 |  3265.5725 |\n|          CPI         |     8.1708 |     8.4779 |     8.1379 |\n|     SP [MFLOP/s]     |  1366.1725 |  1003.3472 |  1120.5229 |\n|   AVX SP [MFLOP/s]   |  1366.1725 |  1003.3472 |  1120.5229 |\n|  AVX512 SP [MFLOP/s] |          0 |          0 |          0 |\n|   Packed [MUOPS/s]   |   170.7716 |   125.4184 |   140.0654 |\n|   Scalar [MUOPS/s]   |          0 |          0 |          0 |\n|  Vectorization ratio |        100 |        100 |        100 |\n+----------------------+------------+------------+------------+\n+---------------------------+------------+-----------+-----------+-----------+\n|           Metric          |     Sum    |    Min    |    Max    |    Avg    |\n+---------------------------+------------+-----------+-----------+-----------+\n|  Runtime (RDTSC) [s] STAT |     0.5242 |    0.1464 |    0.1993 |    0.1747 |\n| Runtime unhalted [s] STAT |     0.3532 |    0.1160 |    0.1209 |    0.1177 |\n|      Clock [MHz] STAT     | 10220.8817 | 3265.3756 | 3689.9336 | 3406.9606 |\n|          CPI STAT         |    24.7866 |    8.1379 |    8.4779 |    8.2622 |\n|     SP [MFLOP/s] STAT     |  3490.0426 | 1003.3472 | 1366.1725 | 1163.3475 |\n|   AVX SP [MFLOP/s] STAT   |  3490.0426 | 1003.3472 | 1366.1725 | 1163.3475 |\n|  AVX512 SP [MFLOP/s] STAT |          0 |         0 |         0 |         0 |\n|   Packed [MUOPS/s] STAT   |   436.2554 |  125.4184 |  170.7716 |  145.4185 |\n|   Scalar [MUOPS/s] STAT   |          0 |         0 |         0 |         0 |\n|  Vectorization ratio STAT |        300 |       100 |       100 |       100 |\n+---------------------------+------------+-----------+-----------+-----------+","category":"page"},{"location":"access/","page":"HPM / Access","title":"HPM / Access","text":"using LIKWID","category":"page"},{"location":"access/#HPM-/-Access","page":"HPM / Access","title":"HPM / Access","text":"","category":"section"},{"location":"access/#API","page":"HPM / Access","title":"API","text":"","category":"section"},{"location":"access/","page":"HPM / Access","title":"HPM / Access","text":"Pages   = [\"access.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"access/#Functions","page":"HPM / Access","title":"Functions","text":"","category":"section"},{"location":"access/","page":"HPM / Access","title":"HPM / Access","text":"Modules = [LIKWID.HPM]","category":"page"},{"location":"access/#LIKWID.HPM.add_thread-Tuple{Any}","page":"HPM / Access","title":"LIKWID.HPM.add_thread","text":"Add the given CPU to the access module. This opens the commnunication to either the MSR/PCI files or the access daemon.\n\n\n\n\n\n","category":"method"},{"location":"access/#LIKWID.HPM.finalize-Tuple{}","page":"HPM / Access","title":"LIKWID.HPM.finalize","text":"Close the connections to the MSR/PCI files or the access daemon.\n\n\n\n\n\n","category":"method"},{"location":"access/#LIKWID.HPM.init-Tuple{}","page":"HPM / Access","title":"LIKWID.HPM.init","text":"Initialize the access module internals to either the MSR/PCI files or the access daemon\n\n\n\n\n\n","category":"method"},{"location":"access/#LIKWID.HPM.mode-Tuple{Union{LIKWID.LibLikwid.AccessMode, Integer}}","page":"HPM / Access","title":"LIKWID.HPM.mode","text":"Sets the mode how the MSR and PCI registers should be accessed. Available options:\n\n0 or LibLikwid.ACCESSMODE_DIRECT: direct access (propably root priviledges required)\n1 or LibLikwid.ACCESSMODE_DAEMON: accesses through the access daemon\n\nMust be called before HPM.init.\n\n\n\n\n\n","category":"method"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"EditURL = \"https://github.com/JuliaPerf/LIKWID.jl/blob/main/docs/docs/src/examples/perfmon.jl\"","category":"page"},{"location":"examples/perfmon/#Monitoring-performance","page":"Monitoring performance","title":"Monitoring performance","text":"","category":"section"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"This is a demo of how to monitor the performance of a computation (do_flops below) running on multiple Julia threads using LIKWID from within Julia (i.e. without using likwid-perfctr ...). You can simply start Julia with julia -t N.","category":"page"},{"location":"examples/perfmon/#Setting-up","page":"Monitoring performance","title":"Setting up","text":"","category":"section"},{"location":"examples/perfmon/#Pinning-the-Julia-threads","page":"Monitoring performance","title":"Pinning the Julia threads","text":"","category":"section"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"It's absolutely necessary to pin the Julia threads to specific cores. Otherwise, the threads might migrate to different cores and our hardware performance counter measurements are meaningless.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"# we'll consider the first `NUM_THREADS` Julia threads\nusing Base.Threads: @threads, nthreads\nconst NUM_THREADS = 3;\nnothing #hide","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"Let's pin the first NUM_THREADS threads to the first NUM_THREADS cores.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"using LIKWID\ncores = 0:NUM_THREADS-1\n@threads :static for tid in 1:NUM_THREADS\n    LIKWID.pinthread(cores[tid])\nend","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"To check that the pinning was successfull, we call LIKWID.get_processor_id on each thread.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"@threads :static for tid in 1:NUM_THREADS\n    core = LIKWID.get_processor_id()\n    println(\"Thread $tid, Core $core\")\nend","category":"page"},{"location":"examples/perfmon/#Environment-variables","page":"Monitoring performance","title":"Environment variables","text":"","category":"section"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"We use the LIKWID.LIKWID_* functions to set environment variables to configure LIKWID for our monitoring.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"# use the following threads\ncpustr = join(collect(0:NUM_THREADS-1), \",\")\nLIKWID.LIKWID_THREADS(cpustr)\n# the location the marker file will be stored\nLIKWID.LIKWID_FILEPATH(joinpath(@__DIR__, \"likwid_marker.out\"))\n# Use the access daemon\nLIKWID.LIKWID_MODE(1)\n# Overwrite registers (if they are in use)\nLIKWID.LIKWID_FORCE(true)\n# Debug level\nLIKWID.LIKWID_DEBUG(0)\n# Events to measure\nLIKWID.LIKWID_EVENTS(\"FLOPS_DP|L2|INSTR_RETIRED_ANY:FIXC0\");\nnothing #hide","category":"page"},{"location":"examples/perfmon/#Initialize-LIKWID-modules","page":"Monitoring performance","title":"Initialize LIKWID modules","text":"","category":"section"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"using LIKWID: PerfMon\nMarker.init_nothreads()\nPerfMon.init()","category":"page"},{"location":"examples/perfmon/#Measurement","page":"Monitoring performance","title":"Measurement","text":"","category":"section"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"First we register the marker region. While this is not required it is strongly recommended as it reduces overhead of Marker.startregion and prevents wrong counts in short regions.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"Note that there must be a barrier between registering a region and starting that region. Typically these are done in separate parallel blocks, relying on the implicit barrier at the end of the parallel block. Usually there is a parallel block for initialization and a parallel block for execution.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"@threads :static for tid in 1:NUM_THREADS\n    Marker.registerregion(\"Total\")\n    Marker.registerregion(\"calc_flops\")\n\n    # To demonstrate that registering regions is optional, we do not register\n    # the \"copy\" region, which we'll use later.\nend;\nnothing #hide","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"Let's get to the actual performance monitoring. We will measure a single region, get the results and reset the region so that these results do not affect (potential) later measurements.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"But first, we'll need to define the computation that we want to analyze.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"# simple function designed to do floating point computations\nfunction do_flops(a, b, c, num_flops)\n    for _ in 1:num_flops\n        c = a * b + c\n    end\n    return c\nend","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"Let's run the computation and monitor the performance. For good measure, we put everything in a function.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"function monitor_do_flops(NUM_FLOPS = 100_000_000)\n    a = 1.8\n    b = 3.2\n    c = 1.0\n    @threads :static for tid in 1:NUM_THREADS\n        # Notice that only the first group specified, `FLOPS_DP`, will be measured.\n        # See further below for how to measure multiple groups.\n        Marker.startregion(\"calc_flops\")\n        c = do_flops(c, a, b, NUM_FLOPS)\n        Marker.stopregion(\"calc_flops\")\n    end\n    return nothing\nend\nmonitor_do_flops()","category":"page"},{"location":"examples/perfmon/#Analysis","page":"Monitoring performance","title":"Analysis","text":"","category":"section"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"To query basic information about the region from all threads we use Marker.getregion.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"@threads :static for threadid in 1:NUM_THREADS\n    nevents, events, time, count = Marker.getregion(\"calc_flops\")\n    gid = PerfMon.get_id_of_active_group()\n    group_name = PerfMon.get_name_of_group(gid)\n    # print basic info\n    println(\"Thread $(threadid): group $(group_name), $(nevents) events, runtime $(time) s, and call count $(count)\")\nend;\nnothing #hide","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"The tools from the LIKWID.PerfMon module can be used to get more detailed information, such as the event and metric results.","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"using PrettyTables\nusing Printf\n_zeroifnothing(x::Nothing) = 0.0\n_zeroifnothing(x) = x\n\n# extract event and metric results\ngid = PerfMon.get_id_of_active_group()\nnevents = PerfMon.get_number_of_events(gid)\nnmetrics = PerfMon.get_number_of_metrics(gid)\nevents = Matrix(undef, nevents, NUM_THREADS + 1)\nmetrics = Matrix(undef, nmetrics, NUM_THREADS + 1)\n\nfor tid in 0:NUM_THREADS-1\n    for eid in 0:nevents-1\n        events[eid+1, 1] = PerfMon.get_name_of_event(gid, eid)\n        events[eid+1, tid+2] = _zeroifnothing(PerfMon.get_result(gid, eid, tid))\n    end\n    for mid in 0:nmetrics-1\n        metrics[mid+1, 1] = PerfMon.get_name_of_metric(gid, mid)\n        metrics[mid+1, tid+2] = _zeroifnothing(PerfMon.get_metric(gid, mid, tid))\n    end\nend\n\n# printing\ntheader = [\"Thread $(i)\" for i in 0:NUM_THREADS-1]\npretty_table(events; header = vcat([\"Event\"], theader))\npretty_table(metrics; header = vcat([\"Metric\"], theader))","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"","category":"page"},{"location":"examples/perfmon/","page":"Monitoring performance","title":"Monitoring performance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"using LIKWID","category":"page"},{"location":"timer/#CPU-Clock-Timer","page":"CPU clock timer","title":"CPU Clock Timer","text":"","category":"section"},{"location":"timer/#Example","page":"CPU clock timer","title":"Example","text":"","category":"section"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"Timing is as simple as","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"LIKWID.Timer.@timeit sleep(1)","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"Apart from the time it took to execute sleep(1) (clock) one also gets the number of CPU clock cycles corresponding to the time interval (cycles).","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"Note that the macro usage above is essentially equivalent to the following manual sequence","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"LIKWID.Timer.init()\nt_start = LIKWID.Timer.start_clock()\nsleep(1)\nt_stop = LIKWID.Timer.stop_clock(t_start)\nLIKWID.Timer.get_clock(t_stop)\nLIKWID.Timer.get_clock_cycles(t_stop)\nLIKWID.Timer.finalize()","category":"page"},{"location":"timer/#API","page":"CPU clock timer","title":"API","text":"","category":"section"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"Pages   = [\"timer.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"timer/#Functions","page":"CPU clock timer","title":"Functions","text":"","category":"section"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"LIKWID.Timer.init\nLIKWID.Timer.finalize\nLIKWID.Timer.get_cpu_clock\nLIKWID.Timer.get_cpu_clock_current\nLIKWID.Timer.start_clock\nLIKWID.Timer.stop_clock\nLIKWID.Timer.get_clock\nLIKWID.Timer.get_clock_cycles\nLIKWID.Timer.timeit\nLIKWID.Timer.@timeit","category":"page"},{"location":"timer/#LIKWID.Timer.init","page":"CPU clock timer","title":"LIKWID.Timer.init","text":"Initialize LIKWIDs timer module\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.finalize","page":"CPU clock timer","title":"LIKWID.Timer.finalize","text":"Close and finalize LIKWIDs timer module\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_cpu_clock","page":"CPU clock timer","title":"LIKWID.Timer.get_cpu_clock","text":"Return the CPU clock determined at Timer.init().\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_cpu_clock_current","page":"CPU clock timer","title":"LIKWID.Timer.get_cpu_clock_current","text":"Return the current CPU clock read from sysfs\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.start_clock","page":"CPU clock timer","title":"LIKWID.Timer.start_clock","text":"Start the clock and return a LibLikwid.TimerData object including the start timestamp.\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.stop_clock","page":"CPU clock timer","title":"LIKWID.Timer.stop_clock","text":"stop_clock(timer::LibLikwid.TimerData) -> newtimer::LibLikwid.TimerData\n\nStop the clock and return a LibLikwid.TimerData object including the start and stop timestamps. The input timer should be the output of Timer.start_clock().\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_clock","page":"CPU clock timer","title":"LIKWID.Timer.get_clock","text":"get_clock(timer::LibLikwid.TimerData)\n\nReturn the measured interval in seconds for the given timer. The input timer should be the output of Timer.stop_clock.\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_clock_cycles","page":"CPU clock timer","title":"LIKWID.Timer.get_clock_cycles","text":"get_clock_cycles(timer::LibLikwid.TimerData)\n\nReturn the measured interval in cycles for the given timer. The input timer should be the output of Timer.stop_clock.\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.timeit","page":"CPU clock timer","title":"LIKWID.Timer.timeit","text":"timeit(f)\n\nTime the given function f using Timer.start_clock, Timer.stop_clock, etc. under the hood. Automatically initializes and finalizes the timer module.\n\nExamples\n\njulia> LIKWID.Timer.timeit() do\n           sleep(1)\n       end\n(clock = 1.0008815780376372, cycles = 3603224844)\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.@timeit","page":"CPU clock timer","title":"LIKWID.Timer.@timeit","text":"Convenience macro for Timer.timeit.\n\nExamples\n\njulia> LIKWID.Timer.@timeit sleep(1)\n(clock = 1.0008815780376372, cycles = 3603224844)\n\n\n\n\n\n","category":"macro"},{"location":"perfmon/#Performance-Monitoring-(PerfMon)","page":"Performance monitoring","title":"Performance Monitoring (PerfMon)","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"The basis functionality of likwid-perfctr.","category":"page"},{"location":"perfmon/#Example","page":"Performance monitoring","title":"Example","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/perfmon.)","category":"page"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"# perfmon.jl\nusing LIKWID\nusing LinearAlgebra\n\nA = rand(128, 64)\nB = rand(64, 128)\nC = zeros(128, 128)\n\ncpu = 0 # starts with zero!\nPerfMon.init(cpu)\ngroupid = PerfMon.add_event_set(\"FLOPS_DP\")\nPerfMon.setup_counters(groupid)\n\nPerfMon.start_counters()\nfor _ in 1:100\n    mul!(C, A, B)\nend\nPerfMon.stop_counters()\n\nmdict = PerfMon.get_metric_results(groupid, cpu)\ndisplay(mdict)\nprintln(); flush(stdout);\nedict = PerfMon.get_event_results(groupid, cpu)\ndisplay(edict)\n\nPerfMon.finalize()","category":"page"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"Running the above with julia perfmon.jl one obtains (modulo architectural differences):","category":"page"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"OrderedCollections.OrderedDict{String, Float64} with 10 entries:\n  \"Runtime (RDTSC) [s]\" => 0.695678\n  \"Runtime unhalted [s]\" => 0.0014145\n  \"Clock [MHz]\" => 1200.12\n  \"CPI\" => 1.00722\n  \"DP [MFLOP/s]\" => 38.2706\n  \"AVX DP [MFLOP/s]\" => 38.2706\n  \"AVX512 DP [MFLOP/s]\" => 38.2706\n  \"Packed [MUOPS/s]\" => 4.78382\n  \"Scalar [MUOPS/s]\" => 0.0\n  \"Vectorization ratio\" => 100.0\nOrderedCollections.OrderedDict{String, Float64} with 7 entries:\n  \"INSTR_RETIRED_ANY\" => 4.63437e6\n  \"CPU_CLK_UNHALTED_CORE\" => 4.66782e6\n  \"CPU_CLK_UNHALTED_REF\" => 1.28352e7\n  \"FP_ARITH_INST_RETIRED_128B_PACKED_DOUBLE\" => 0.0\n  \"FP_ARITH_INST_RETIRED_SCALAR_DOUBLE\" => 0.0\n  \"FP_ARITH_INST_RETIRED_256B_PACKED_DOUBLE\" => 0.0\n  \"FP_ARITH_INST_RETIRED_512B_PACKED_DOUBLE\" => 3.328e6","category":"page"},{"location":"perfmon/#API","page":"Performance monitoring","title":"API","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"Pages   = [\"perfmon.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"perfmon/#Functions","page":"Performance monitoring","title":"Functions","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"Modules = [LIKWID.PerfMon]","category":"page"},{"location":"perfmon/#LIKWID.PerfMon.add_event_set-Tuple{AbstractString}","page":"Performance monitoring","title":"LIKWID.PerfMon.add_event_set","text":"add_event_set(estr) -> groupid\n\nAdd a performance group or a custom event set to the perfmon module. Returns a groupid (starting at 1) which is required to later specify the event set.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_event_results-Tuple{Any, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_event_results","text":"get_event_results([groupid_or_groupname, eventid_or_eventname, threadid::Integer])\n\nRetrieve the results of monitored events. Same as get_metric_results but for raw events.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_id_of_active_group-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_id_of_active_group","text":"Return the groupid of the currently activate group.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_id_of_event-Tuple{Any, AbstractString}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_id_of_event","text":"Get the id of the event with the given name.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_id_of_group-Tuple{AbstractString}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_id_of_group","text":"Get the id of the group with the given name.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_id_of_metric-Tuple{Any, AbstractString}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_id_of_metric","text":"Get the id of the metric with the given name.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_last_metric-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_last_metric","text":"Return the derived metric result of the last measurement cycle identified by group groupid and the indices for metric metricidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_last_result-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_last_result","text":"Return the raw counter register result of the last measurement cycle identified by group groupid and the indices for event eventidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_longinfo_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_longinfo_of_group","text":"Return the (long) description of a performance group with id groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_metric-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_metric","text":"Return the derived metric result of all measurements identified by group groupid and the indices for metric metricidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_metric_results-Tuple{Any, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_metric_results","text":"get_metric_results([groupid_or_groupname, metricid_or_metricname, threadid::Integer])\n\nRetrieve the results of monitored metrics.\n\nOptionally, a group, metric, and threadid can be provided to select a subset of metrics or a single metric. If given as integers, note that groupid, metricid, and threadid all start at 1 and the latter enumerates the monitored cpu threads.\n\nIf no arguments are provided, a nested data structure is returned in which different levels correspond to performance groups, cpu threads, and metrics (in this order).\n\nExamples\n\njulia> PerfMon.get_metric_results(\"FLOPS_DP\")\n4-element Vector{OrderedDict{String, Float64}}:\n OrderedDict(\"Runtime (RDTSC) [s]\" => 1.1381168037989857, \"Runtime unhalted [s]\" => 0.0016642799007831007, \"Clock [MHz]\" => 2911.9285695819794, \"CPI\" => NaN, \"DP [MFLOP/s]\" => 0.0)\n OrderedDict(\"Runtime (RDTSC) [s]\" => 1.1381168037989857, \"Runtime unhalted [s]\" => 1.4755564705029072, \"Clock [MHz]\" => 3523.1114993407705, \"CPI\" => 0.3950777002592585, \"DP [MFLOP/s]\" => 17608.069202657578)\n OrderedDict(\"Runtime (RDTSC) [s]\" => 1.1381168037989857, \"Runtime unhalted [s]\" => 7.80437228993214e-5, \"Clock [MHz]\" => 2638.6244625814124, \"CPI\" => NaN, \"DP [MFLOP/s]\" => 0.0)\n OrderedDict(\"Runtime (RDTSC) [s]\" => 1.1381168037989857, \"Runtime unhalted [s]\" => 7.050705084934875e-5, \"Clock [MHz]\" => 2807.7525945849698, \"CPI\" => NaN, \"DP [MFLOP/s]\" => 0.0)\n\njulia> PerfMon.get_metric_results(\"FLOPS_DP\", 2) # results of second monitored cpu thread\nOrderedDict{String, Float64} with 5 entries:\n  \"Runtime (RDTSC) [s]\"  => 1.13812\n  \"Runtime unhalted [s]\" => 1.47556\n  \"Clock [MHz]\"          => 3523.11\n  \"CPI\"                  => 0.395078\n  \"DP [MFLOP/s]\"         => 17608.1\n\njulia> PerfMon.get_metric_results(\"FLOPS_DP\", \"DP [MFLOP/s]\", 2)\n17608.069202657578\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_metric_results-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_metric_results","text":"get_metric_results()\n\nGet the metric results for all performance groups and all monitored (PerfMon.init) cpu threads.\n\nReturns a an OrderedDict whose keys correspond to the performance groups and the values hold the results for all monitored cpu threads.\n\nExamples\n\njulia> results = PerfMon.get_metric_results()\nOrderedDict{String, Vector{OrderedDict{String, Float64}}} with 1 entry:\n  \"FLOPS_DP\" => [OrderedDict(\"Runtime (RDTSC) [s]\"=>1.13812, \"Runtime unhalted [s]\"=>0.00166428, \"Clock [MHz]\"=>291…\n\njulia> PerfMon.get_metric_results()[\"FLOPS_DP\"][2][\"DP [MFLOP/s]\"]\n17608.069202657578\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_counter-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_counter","text":"Return the name of the counter register identified by groupid and eventidx (both starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_event-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_event","text":"Return the name of the event identified by groupid and eventidx (both starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_group","text":"Return the name of the group identified by groupid (starts at 1). If it is a custom event set, the name is set to Custom.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_metric-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_metric","text":"Return the name of a derived metric identified by groupid and metricidx (both starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_events-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_events","text":"Return the amount of events in the given group with id groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_groups-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_groups","text":"Return the number of groups currently registered in the perfmon module.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_metrics-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_metrics","text":"Return the amount of metrics in the given group with id groupid (starts at 1). Always zero for custom event sets.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_threads-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_threads","text":"Return the number of threads initialized in the perfmon module.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_result-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_result","text":"Return the raw counter register result of all measurements identified by group groupid and the indices for event eventidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_shortinfo_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_shortinfo_of_group","text":"Return the short information about a performance group with id groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_time_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_time_of_group","text":"Return the measurement time for group identified by groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.isgroupsupported-Tuple{Any}","page":"Performance monitoring","title":"LIKWID.PerfMon.isgroupsupported","text":"Checks if the given performance group is available on the current system.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.list_events-Tuple{Any}","page":"Performance monitoring","title":"LIKWID.PerfMon.list_events","text":"List all the events of a given group (groupid starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.list_metrics-Tuple{Any}","page":"Performance monitoring","title":"LIKWID.PerfMon.list_metrics","text":"List all the metrics of a given group (groupid starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.perfmon-Tuple{Any, Any}","page":"Performance monitoring","title":"LIKWID.PerfMon.perfmon","text":"perfmon(f, group_or_groups[; cpuids, autopin=true])\n\nMonitor performance groups while executing the given function f on one or multiple Julia threads. Note that\n\nPerfMon.init and PerfMon.finalize are called automatically\nthe measurement of multiple performance groups is sequential and requires multiple executions of f!\n\nKeyword arguments:\n\ncpuids (default: currently used CPU threads): specify the CPU threads (~ cores) to be monitored\nautopin (default: true): automatically pin Julia threads to the CPU threads (~ cores) they are currently running on (to avoid migration and wrong results).\n\nExample\n\njulia> using LIKWID\n\njulia> x = rand(1000); y = rand(1000);\n\njulia> metrics, events = perfmon(\"FLOPS_DP\") do\n           x .+ y;\n       end;\n\njulia> metrics                                                                      \nOrderedDict{String, Float64} with 5 entries:\n  \"Runtime (RDTSC) [s]\"  => 8.56091e-6\n  \"Runtime unhalted [s]\" => 3.22377e-5\n  \"Clock [MHz]\"          => 3506.47\n  \"CPI\"                  => 4.78484\n  \"DP [MFLOP/s]\"         => 116.81\n                                          \njulia> events                                                                       \nOrderedDict{String, Float64} with 6 entries:\n  \"ACTUAL_CPU_CLOCK\"          => 78974.0\n  \"MAX_CPU_CLOCK\"             => 55174.0\n  \"RETIRED_INSTRUCTIONS\"      => 5977.0\n  \"CPU_CLOCKS_UNHALTED\"       => 28599.0\n  \"RETIRED_SSE_AVX_FLOPS_ALL\" => 1000.0\n  \"MERGE\"                     => 0.0\n\njulia> metrics, events = perfmon((\"FLOPS_DP\", \"MEM1\")) do\n           x .+ y;\n       end;\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.read_counters-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.read_counters","text":"Read the counter registers. To be executed after start_counters and before stop_counters. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.setup_counters-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.setup_counters","text":"Program the counter registers to measure all events in group groupid (starts at 1). Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.start_counters-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.start_counters","text":"Start the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.stop_counters-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.stop_counters","text":"Stop the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.supported_groups-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.supported_groups","text":"Return a list of all available perfmon groups.\n\nExamples\n\njulia> PerfMon.supported_groups()\n30-element Vector{LIKWID.GroupInfoCompact}:\n MEM_SP => Overview of arithmetic and main memory performance\n CYCLE_ACTIVITY => Cycle Activities\n ENERGY => Power and Energy consumption\n UOPS_RETIRE => UOPs retirement\n PMM => Intel Optane DC bandwidth in MBytes/s\n TLB_INSTR => L1 Instruction TLB miss rate/ratio\n DATA => Load to store ratio\n UOPS_ISSUE => UOPs issueing\n L2CACHE => L2 cache miss rate/ratio\n L2 => L2 cache bandwidth in MBytes/s\n ⋮\n TMA => Top down cycle allocation\n CLOCK => Power and Energy consumption\n FLOPS_DP => Double Precision MFLOP/s\n CYCLE_STALLS => Cycle Activities (Stalls)\n L3 => L3 cache bandwidth in MBytes/s\n UPI => UPI traffic\n L3NEW => L3 cache bandwidth in MBytes/s\n L3PF => L3 cache bandwidth in MBytes/s\n L2L3 => L3 cache bandwidth in MBytes/s\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.switch_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.switch_group","text":"Switch currently active group to groupid (starts with 1). Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.@perfmon-Tuple{AbstractString, Any}","page":"Performance monitoring","title":"LIKWID.PerfMon.@perfmon","text":"@perfmon groupname codeblock\n\nSee also: perfmon\n\nExample\n\njulia> using LIKWID\n\njulia> x = rand(1000); y = rand(1000);\n\njulia> metrics, events = @perfmon \"FLOPS_DP\" x .+ y;\n\njulia> metrics                                                                      \nOrderedDict{String, Float64} with 5 entries:\n  \"Runtime (RDTSC) [s]\"  => 8.56091e-6\n  \"Runtime unhalted [s]\" => 3.22377e-5\n  \"Clock [MHz]\"          => 3506.47\n  \"CPI\"                  => 4.78484\n  \"DP [MFLOP/s]\"         => 116.81\n                                          \njulia> events                                                                       \nOrderedDict{String, Float64} with 6 entries:\n  \"ACTUAL_CPU_CLOCK\"          => 78974.0\n  \"MAX_CPU_CLOCK\"             => 55174.0\n  \"RETIRED_INSTRUCTIONS\"      => 5977.0\n  \"CPU_CLOCKS_UNHALTED\"       => 28599.0\n  \"RETIRED_SSE_AVX_FLOPS_ALL\" => 1000.0\n  \"MERGE\"                     => 0.0\n\n\n\n\n\n","category":"macro"},{"location":"perfmon/#Types","page":"Performance monitoring","title":"Types","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"LIKWID.GroupInfoCompact","category":"page"},{"location":"perfmon/#LIKWID.GroupInfoCompact","page":"Performance monitoring","title":"LIKWID.GroupInfoCompact","text":"Essential information about a performance group\n\n\n\n\n\n","category":"type"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#API","page":"Miscellaneous","title":"API","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Pages   = [\"misc.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"misc/#Functions","page":"Miscellaneous","title":"Functions","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"LIKWID.setverbosity\nLIKWID.gpusupport\nLIKWID.accessmode\nLIKWID.env\nLIKWID.LIKWID_FORCE\nLIKWID.LIKWID_NO_ACCESS\nLIKWID.LIKWID_PIN\nLIKWID.LIKWID_SILENT\nLIKWID.LIKWID_SKIP\nLIKWID.LIKWID_DEBUG\nLIKWID.LIKWID_IGNORE_CPUSET\nLIKWID.LIKWID_FILEPATH\nLIKWID.LIKWID_MODE\nLIKWID.LIKWID_EVENTS\nLIKWID.LIKWID_THREADS\nLIKWID.LIKWID_MPI_CONNECT","category":"page"},{"location":"misc/#LIKWID.setverbosity","page":"Miscellaneous","title":"LIKWID.setverbosity","text":"Set the verbosity level of the LIKWID library. Returns true on success.\n\nOptions are:\n\nLIKWID.LibLikwid.DEBUGLEV_ONLY_ERROR or 0\nLIKWID.LibLikwid.DEBUGLEV_INFO or 1\nLIKWID.LibLikwid.DEBUGLEV_DETAIL or 2\nLIKWID.LibLikwid.DEBUGLEV_DEVELOP or 3\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.gpusupport","page":"Miscellaneous","title":"LIKWID.gpusupport","text":"Returns whether LIKWID has been compiled with GPU support (i.e. has been compiled with NVIDIA_INTERFACE=true).\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.accessmode","page":"Miscellaneous","title":"LIKWID.accessmode","text":"Query the access mode used by LIKWID, i.e. either ACCESSMODE_PERF, ACCESSMODE_DAEMON, or ACCESSMODE_DIRECT.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.env","page":"Miscellaneous","title":"LIKWID.env","text":"List the values of LIKWID_* environment variables.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_FORCE","page":"Miscellaneous","title":"LIKWID.LIKWID_FORCE","text":"Enables the overwriting of counters that are detected to be in-use. The environment variable is similar to the -f/--force command line switch for likwid-perfctr.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_NO_ACCESS","page":"Miscellaneous","title":"LIKWID.LIKWID_NO_ACCESS","text":"The execution does not require the access layer (access to hardware counters). For example, this variable is set by likwid-topology or likwid-pin.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_PIN","page":"Miscellaneous","title":"LIKWID.LIKWID_PIN","text":"The comma-separated list contains the CPUs the application threads should be pinned to. Careful, the first CPU in the cpuset must be the last entry because the application is pinned to this CPU per default.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_SILENT","page":"Miscellaneous","title":"LIKWID.LIKWID_SILENT","text":"Disable stdout output caused by the library and the scripts. Some scripts provide the -q/--quiet command line switch which provides the same functionality.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_SKIP","page":"Miscellaneous","title":"LIKWID.LIKWID_SKIP","text":"Variable content must be a hexmask. This hexmask describes which threads should be skipped while pinning. This function is required to avoid pinning the shepherd threads used by some OpenMP and MPI implementations. The version 4.3.1 introduced an automatic detection of the shepherd threads. In most cases the detection works, but if not, the hexmask overwrites the automatic detection.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_DEBUG","page":"Miscellaneous","title":"LIKWID.LIKWID_DEBUG","text":"Verbosity settings for the LIKWID library.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_IGNORE_CPUSET","page":"Miscellaneous","title":"LIKWID.LIKWID_IGNORE_CPUSET","text":"LIKWID respects the CPUset of the calling process. If you want to measure/run outside of this CPUset, use this environment variable. It will not ignore the CPUset but create a new CPUset internally which contains sysconf(_SC_NPROCESSORS_CONF) hardware threads.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_FILEPATH","page":"Miscellaneous","title":"LIKWID.LIKWID_FILEPATH","text":"Filepath for the result file of the MarkerAPI.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_MODE","page":"Miscellaneous","title":"LIKWID.LIKWID_MODE","text":"Access mode for MarkerAPI. 1 is the code for the access daemon.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_EVENTS","page":"Miscellaneous","title":"LIKWID.LIKWID_EVENTS","text":"Event string or performance group name. Multiple event strings or performance group names can be separated by |.\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_THREADS","page":"Miscellaneous","title":"LIKWID.LIKWID_THREADS","text":"The CPUs LIKWID is configured to run on (comma-separated list).\n\n\n\n\n\n","category":"function"},{"location":"misc/#LIKWID.LIKWID_MPI_CONNECT","page":"Miscellaneous","title":"LIKWID.LIKWID_MPI_CONNECT","text":"Connection method for Intel MPI. Default is ssh, see option -r of mpdboot or similar.\n\n\n\n\n\n","category":"function"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"EditURL = \"https://github.com/JuliaPerf/LIKWID.jl/blob/main/docs/docs/src/examples/dynamic_pinning.jl\"","category":"page"},{"location":"examples/dynamic_pinning/#Pinning-Julia-Threads","page":"Thread Pinning","title":"Pinning Julia Threads","text":"","category":"section"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"In the following, we demonstrate how to use LIKWID.jl to pin Julia threads to specific cores.","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"note: Note\nInstead of LIKWID's pinning features, we strongly recommend to use ThreadPinning.jl to pin Julia threads to cores!","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"note: Note\nNote that Julia implements task-based multithreading where N tasks get mapped onto M OS threads (M:N hybrid threading). We will pin the Julia (p)threads and not the tasks. Depending on how the latter are started/configured, tasks may migrate between Julia threads!","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"First, we load the packages and standard libraries that we'll use.","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"using LIKWID\nusing Base.Threads: nthreads, @threads\nusing Test, Random","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"Note that I have started julia with multiple threads (julia -t N), concretely","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"NT = nthreads()","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"Let's find out on which cores are running our Julia threads. We will use LIKWID.get_processor_id in combination with @threads :static for, which guarantees that the associated tasks are themselves pinned to Julia threads.","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"coreids = zeros(Int, NT)\n@threads :static for i in 1:NT\n    coreids[i] = LIKWID.get_processor_id()\nend\nprintln(\"Cores: \", coreids)","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"Since querying all core ids is a common operation, we provide LIKWID.get_processor_ids which returns all core ids right away.","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"To pin a thread to a specific core, there is LIKWID.pinthread. Using @threads :static for like above, we can, for example, pin the NT Julia threads to the first NT cores:","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"# core numbering starts with zero\ncores_firstNT = 0:NT-1\n@threads :static for i in 1:NT\n    LIKWID.pinthread(cores_firstNT[i])\nend\n@test LIKWID.get_processor_ids() == cores_firstNT","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"To avoid the explicit for-loop, we can directly use LIKWID.pinthreads to pin all Julia threads.","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"Let's try a less trivial shuffled mapping","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"cores_firstNT_shuffeled = shuffle(cores_firstNT)\nLIKWID.pinthreads(cores_firstNT_shuffeled)\n@test LIKWID.get_processor_ids() == cores_firstNT_shuffeled","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"","category":"page"},{"location":"examples/dynamic_pinning/","page":"Thread Pinning","title":"Thread Pinning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"using LIKWID","category":"page"},{"location":"affinity/#Affinity","page":"Affinity","title":"Affinity","text":"","category":"section"},{"location":"affinity/#Example","page":"Affinity","title":"Example","text":"","category":"section"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"Query affinity domain information:","category":"page"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"aff = LIKWID.get_affinity()\naff.domains","category":"page"},{"location":"affinity/#API","page":"Affinity","title":"API","text":"","category":"section"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"Pages   = [\"affinity.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"affinity/#Functions","page":"Affinity","title":"Functions","text":"","category":"section"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"LIKWID.init_affinity\nLIKWID.finalize_affinity\nLIKWID.get_affinity\nLIKWID.cpustr_to_cpulist\nLIKWID.get_processor_id\nLIKWID.get_processor_ids\nLIKWID.get_processor_id_glibc\nLIKWID.pinprocess\nLIKWID.pinthread\nLIKWID.pinthreads","category":"page"},{"location":"affinity/#LIKWID.init_affinity","page":"Affinity","title":"LIKWID.init_affinity","text":"Initialize LIKWIDs affinity domain module.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.finalize_affinity","page":"Affinity","title":"LIKWID.finalize_affinity","text":"Close and finalize LIKWIDs affinity domain module.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.get_affinity","page":"Affinity","title":"LIKWID.get_affinity","text":"Query affinity domain information\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.cpustr_to_cpulist","page":"Affinity","title":"LIKWID.cpustr_to_cpulist","text":"Transform a valid cpu string in LIKWID syntax into a list of CPU IDs\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.get_processor_id","page":"Affinity","title":"LIKWID.get_processor_id","text":"Returns the ID of the currently executing CPU.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.get_processor_ids","page":"Affinity","title":"LIKWID.get_processor_ids","text":"Get the CPU core IDs of the Julia threads.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.get_processor_id_glibc","page":"Affinity","title":"LIKWID.get_processor_id_glibc","text":"Returns the ID of the currently executing CPU via glibcs sched_getcpu function.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.pinprocess","page":"Affinity","title":"LIKWID.pinprocess","text":"Pins the current process to the CPU given as cpuid.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.pinthread","page":"Affinity","title":"LIKWID.pinthread","text":"Pins the current thread to the CPU given as cpuid.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.pinthreads","page":"Affinity","title":"LIKWID.pinthreads","text":"Pin all Julia threads to the CPU cores coreids. Note that length(coreids) == Threads.nthreads() must hold!\n\n\n\n\n\n","category":"function"},{"location":"affinity/#Types","page":"Affinity","title":"Types","text":"","category":"section"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"LIKWID.AffinityDomains\nLIKWID.AffinityDomain","category":"page"},{"location":"affinity/#LIKWID.AffinityDomains","page":"Affinity","title":"LIKWID.AffinityDomains","text":"Information about the affinity domains\n\n\n\n\n\n","category":"type"},{"location":"affinity/#LIKWID.AffinityDomain","page":"Affinity","title":"LIKWID.AffinityDomain","text":"An affinity domain\n\n\n\n\n\n","category":"type"},{"location":"topo_gpu/","page":"GPU topology","title":"GPU topology","text":"using LIKWID","category":"page"},{"location":"topo_gpu/#GPU-Topology","page":"GPU topology","title":"GPU Topology","text":"","category":"section"},{"location":"topo_gpu/#Example","page":"GPU topology","title":"Example","text":"","category":"section"},{"location":"topo_gpu/","page":"GPU topology","title":"GPU topology","text":"Query GPU topology information:","category":"page"},{"location":"topo_gpu/","page":"GPU topology","title":"GPU topology","text":"topo = LIKWID.get_gpu_topology()\ntopo.devices\ngpu = first(topo.devices)","category":"page"},{"location":"topo_gpu/#API","page":"GPU topology","title":"API","text":"","category":"section"},{"location":"topo_gpu/","page":"GPU topology","title":"GPU topology","text":"Pages   = [\"topo_gpu.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"topo_gpu/#Functions","page":"GPU topology","title":"Functions","text":"","category":"section"},{"location":"topo_gpu/","page":"GPU topology","title":"GPU topology","text":"LIKWID.init_topology_gpu()\nLIKWID.finalize_topology_gpu()\nLIKWID.get_gpu_topology()","category":"page"},{"location":"topo_gpu/#LIKWID.init_topology_gpu-Tuple{}","page":"GPU topology","title":"LIKWID.init_topology_gpu","text":"Initialize LIKWIDs GPU topology module.\n\n\n\n\n\n","category":"method"},{"location":"topo_gpu/#LIKWID.finalize_topology_gpu-Tuple{}","page":"GPU topology","title":"LIKWID.finalize_topology_gpu","text":"Finalize LIKWIDs GPU topology module.\n\n\n\n\n\n","category":"method"},{"location":"topo_gpu/#LIKWID.get_gpu_topology-Tuple{}","page":"GPU topology","title":"LIKWID.get_gpu_topology","text":"Get GPU topology\n\n\n\n\n\n","category":"method"},{"location":"topo_gpu/#Types","page":"GPU topology","title":"Types","text":"","category":"section"},{"location":"topo_gpu/","page":"GPU topology","title":"GPU topology","text":"LIKWID.GpuTopology\nLIKWID.GpuDevice","category":"page"},{"location":"topo_gpu/#LIKWID.GpuTopology","page":"GPU topology","title":"LIKWID.GpuTopology","text":"Topology information of GPUs\n\n\n\n\n\n","category":"type"},{"location":"topo_gpu/#LIKWID.GpuDevice","page":"GPU topology","title":"LIKWID.GpuDevice","text":"Detailed information about a GPU device\n\n\n\n\n\n","category":"type"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"using LIKWID","category":"page"},{"location":"topo/#CPU-/-NUMA-Topology","page":"CPU topology","title":"CPU / NUMA Topology","text":"","category":"section"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"The basis functionality of likwid-topology.","category":"page"},{"location":"topo/#Example","page":"CPU topology","title":"Example","text":"","category":"section"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"Query CPU topology information:","category":"page"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"topo = LIKWID.get_cpu_topology()\ntopo.threadPool\ntopo.cacheLevels","category":"page"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"Get detailed CPU information:","category":"page"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"cpuinfo = LIKWID.get_cpu_info()","category":"page"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"Query information about NUMA nodes:","category":"page"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"numa = LIKWID.get_numa_topology()\nnuma.nodes\nnuma_node = first(numa.nodes)","category":"page"},{"location":"topo/#Graphical-output","page":"CPU topology","title":"Graphical output","text":"","category":"section"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"Currently, LIKWID.jl doesn't feature a native graphical visualization of the CPU topology. However, it provides a small \"wrapper function\" around likwid-topology -g which should give you an output like this:","category":"page"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"LIKWID.print_cpu_topology()","category":"page"},{"location":"topo/#API","page":"CPU topology","title":"API","text":"","category":"section"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"Pages   = [\"topo.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"topo/#Functions","page":"CPU topology","title":"Functions","text":"","category":"section"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"LIKWID.init_topology\nLIKWID.finalize_topology\nLIKWID.get_cpu_topology\nLIKWID.get_cpu_info\nLIKWID.print_supported_cpus\nLIKWID.init_numa\nLIKWID.finalize_numa\nLIKWID.get_numa_topology","category":"page"},{"location":"topo/#LIKWID.init_topology","page":"CPU topology","title":"LIKWID.init_topology","text":"Initialize LIKWIDs topology module.\n\n\n\n\n\n","category":"function"},{"location":"topo/#LIKWID.finalize_topology","page":"CPU topology","title":"LIKWID.finalize_topology","text":"Close and finalize LIKWIDs topology module.\n\n\n\n\n\n","category":"function"},{"location":"topo/#LIKWID.get_cpu_topology","page":"CPU topology","title":"LIKWID.get_cpu_topology","text":"get_cpu_topology() -> CpuTopology\n\nGet the CPU topology of the machine.\n\nAutomatically initializes the topology and NUMA modules, i.e. calls LIKWID.init_topology and LIKWID.init_numa.\n\n\n\n\n\n","category":"function"},{"location":"topo/#LIKWID.get_cpu_info","page":"CPU topology","title":"LIKWID.get_cpu_info","text":"get_cpu_info() -> CpuInfo\n\nGet detailed information about the CPU.\n\nAutomatically initializes the topology and NUMA modules, i.e. calls LIKWID.init_topology and LIKWID.init_numa.\n\n\n\n\n\n","category":"function"},{"location":"topo/#LIKWID.print_supported_cpus","page":"CPU topology","title":"LIKWID.print_supported_cpus","text":"print_supported_cpus(; cprint=true)\n\nPrint a list of all supported CPUs.\n\nIf cprint=false, LIKWID.jl will first capture the stdout and then print the list.\n\n\n\n\n\n","category":"function"},{"location":"topo/#LIKWID.init_numa","page":"CPU topology","title":"LIKWID.init_numa","text":"Initialize LIKWIDs NUMA module.\n\n\n\n\n\n","category":"function"},{"location":"topo/#LIKWID.finalize_numa","page":"CPU topology","title":"LIKWID.finalize_numa","text":"Close and finalize LIKWIDs NUMA module.\n\n\n\n\n\n","category":"function"},{"location":"topo/#LIKWID.get_numa_topology","page":"CPU topology","title":"LIKWID.get_numa_topology","text":"get_numa_topology() -> NumaTopology\n\nGet the NUMA topology of the machine.\n\nAutomatically initializes the topology, NUMA, and affinity modules, i.e. calls LIKWID.init_topology, LIKWID.init_numa, and LIKWID.init_affinity.\n\n\n\n\n\n","category":"function"},{"location":"topo/#Types","page":"CPU topology","title":"Types","text":"","category":"section"},{"location":"topo/","page":"CPU topology","title":"CPU topology","text":"LIKWID.CpuTopology\nLIKWID.CpuInfo\nLIKWID.HWThread\nLIKWID.CacheLevel\nLIKWID.NumaTopology\nLIKWID.NumaNode","category":"page"},{"location":"topo/#LIKWID.CpuTopology","page":"CPU topology","title":"LIKWID.CpuTopology","text":"CPU topology information\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.CpuInfo","page":"CPU topology","title":"LIKWID.CpuInfo","text":"CPU information\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.HWThread","page":"CPU topology","title":"LIKWID.HWThread","text":"Information about a hardware thread\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.CacheLevel","page":"CPU topology","title":"LIKWID.CacheLevel","text":"Information about a cache level\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.NumaTopology","page":"CPU topology","title":"LIKWID.NumaTopology","text":"CPU topology information\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.NumaNode","page":"CPU topology","title":"LIKWID.NumaNode","text":"Information about a NUMA node\n\n\n\n\n\n","category":"type"},{"location":"temperature/","page":"CPU temperature","title":"CPU temperature","text":"using LIKWID","category":"page"},{"location":"temperature/#CPU-Temperature","page":"CPU temperature","title":"CPU Temperature","text":"","category":"section"},{"location":"temperature/#API","page":"CPU temperature","title":"API","text":"","category":"section"},{"location":"temperature/","page":"CPU temperature","title":"CPU temperature","text":"Pages   = [\"temperature.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"temperature/#Functions","page":"CPU temperature","title":"Functions","text":"","category":"section"},{"location":"temperature/","page":"CPU temperature","title":"CPU temperature","text":"LIKWID.init_thermal\nLIKWID.get_temperature","category":"page"},{"location":"temperature/#LIKWID.init_thermal","page":"CPU temperature","title":"LIKWID.init_thermal","text":"Initialize thermal measurements on the given CPU.\n\n\n\n\n\n","category":"function"},{"location":"temperature/#LIKWID.get_temperature","page":"CPU temperature","title":"LIKWID.get_temperature","text":"Read the current temperature of the given CPU in degrees Celsius.\n\n\n\n\n\n","category":"function"},{"location":"marker/#Marker-API-(CPU)","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"","category":"section"},{"location":"marker/#Example","page":"Marker API (CPU)","title":"Example","text":"","category":"section"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/perfctr.)","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"# perfctr.jl\nusing LIKWID\nusing LinearAlgebra\n\nMarker.init()\n\nA = rand(128, 64)\nB = rand(64, 128)\nC = zeros(128, 128)\n\nMarker.startregion(\"matmul\")\nfor _ in 1:100\n    mul!(C, A, B)\nend\nMarker.stopregion(\"matmul\")\n\nMarker.close()","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Running this file with the command likwid-perfctr -C 0 -g FLOPS_DP -m julia perfctr.jl one should obtain something like the following:","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6246 CPU @ 3.30GHz\nCPU type:\tIntel Cascadelake SP processor\nCPU clock:\t3.30 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion matmul, Group 1: FLOPS_DP\n+-------------------+------------+\n|    Region Info    | HWThread 0 |\n+-------------------+------------+\n| RDTSC Runtime [s] |   0.621329 |\n|     call count    |          1 |\n+-------------------+------------+\n+------------------------------------------+---------+------------+\n|                   Event                  | Counter | HWThread 0 |\n+------------------------------------------+---------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  | 4151839000 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  | 2548859000 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  | 2004161000 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_DOUBLE |   PMC0  |          0 |\n|    FP_ARITH_INST_RETIRED_SCALAR_DOUBLE   |   PMC1  |       1572 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_DOUBLE |   PMC2  |          0 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_DOUBLE |   PMC3  |   26624000 |\n+------------------------------------------+---------+------------+\n+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.6213 |\n| Runtime unhalted [s] |     0.7724 |\n|      Clock [MHz]     |  4196.5492 |\n|          CPI         |     0.6139 |\n|     DP [MFLOP/s]     |   342.8031 |\n|   AVX DP [MFLOP/s]   |   342.8006 |\n|  AVX512 DP [MFLOP/s] |   342.8006 |\n|   Packed [MUOPS/s]   |    42.8501 |\n|   Scalar [MUOPS/s]   |     0.0025 |\n|  Vectorization ratio |    99.9941 |\n+----------------------+------------+","category":"page"},{"location":"marker/#Convenience-macro","page":"Marker API (CPU)","title":"Convenience macro","text":"","category":"section"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"We provide (and export) the macro @region which can be used to write regions like","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Marker.startregion(\"matmul\")\nfor _ in 1:100\n    mul!(C, A, B)\nend\nMarker.stopregion(\"matmul\")","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"simply as","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"@region \"matmul\" for _ in 1:100\n    mul!(C, A, B)\nend","category":"page"},{"location":"marker/#SIMD-/-AVX","page":"Marker API (CPU)","title":"SIMD / AVX","text":"","category":"section"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Let's run the same example as above on a Rocketlacke processor. We might get the following.","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"--------------------------------------------------------------------------------\nCPU name:\t11th Gen Intel(R) Core(TM) i7-11700K @ 3.60GHz\nCPU type:\tIntel Rocketlake processor\nCPU clock:\t3.60 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion matmul, Group 1: FLOPS_DP\n+-------------------+------------+\n|    Region Info    | HWThread 0 |\n+-------------------+------------+\n| RDTSC Runtime [s] |   0.465348 |\n|     call count    |          1 |\n+-------------------+------------+\n\n+------------------------------------------+---------+------------+\n|                   Event                  | Counter | HWThread 0 |\n+------------------------------------------+---------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  | 4414042000 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  | 2237935000 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  | 1648606000 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_DOUBLE |   PMC0  |  106496000 |\n|    FP_ARITH_INST_RETIRED_SCALAR_DOUBLE   |   PMC1  |        569 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_DOUBLE |   PMC2  |          0 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_DOUBLE |   PMC3  |          0 |\n+------------------------------------------+---------+------------+\n\n+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.4653 |\n| Runtime unhalted [s] |     0.6217 |\n|      Clock [MHz]     |  4886.7513 |\n|          CPI         |     0.5070 |\n|     DP [MFLOP/s]     |   457.7061 |\n|   AVX DP [MFLOP/s]   |          0 |\n|  AVX512 DP [MFLOP/s] |          0 |\n|   Packed [MUOPS/s]   |   228.8524 |\n|   Scalar [MUOPS/s]   |     0.0012 |\n|  Vectorization ratio |    99.9995 |\n+----------------------+------------+","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Given the absence of AVX calls, it seems like OpenBLAS is falling back to a suboptimal Nehalem kernel. If we install MKL.jl and add using MKL to the top of our script above, the metrics table becomes","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.4599 |\n| Runtime unhalted [s] |     0.6065 |\n|      Clock [MHz]     |  4888.9102 |\n|          CPI         |     0.5145 |\n|     DP [MFLOP/s]     |   459.6089 |\n|   AVX DP [MFLOP/s]   |   459.6080 |\n|  AVX512 DP [MFLOP/s] |   459.6080 |\n|   Packed [MUOPS/s]   |    57.4510 |\n|   Scalar [MUOPS/s]   |     0.0008 |\n|  Vectorization ratio |    99.9986 |\n+----------------------+------------+","category":"page"},{"location":"marker/#likwid-perfctr-in-a-nutshell","page":"Marker API (CPU)","title":"likwid-perfctr in a nutshell","text":"","category":"section"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Most importantly, you need to use the -m option to activate the marker API.","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"To list the available performance groups, run likwid-perfctr -a:","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"PerfMon group name\tDescription\n--------------------------------------------------------------------------------\n        MEM_SP\tOverview of arithmetic and main memory performance\nCYCLE_ACTIVITY\tCycle Activities\n        ENERGY\tPower and Energy consumption\n   UOPS_RETIRE\tUOPs retirement\n           PMM\tIntel Optane DC bandwidth in MBytes/s\n     TLB_INSTR\tL1 Instruction TLB miss rate/ratio\n          DATA\tLoad to store ratio\n    UOPS_ISSUE\tUOPs issueing\n       L2CACHE\tL2 cache miss rate/ratio\n            L2\tL2 cache bandwidth in MBytes/s\n     FLOPS_AVX\tPacked AVX MFLOP/s\n           MEM\tMain memory bandwidth in MBytes/s\n        BRANCH\tBranch prediction miss rate/ratio\n      FLOPS_SP\tSingle Precision MFLOP/s\n        MEM_DP\tOverview of arithmetic and main memory performance\n       L3CACHE\tL3 cache miss rate/ratio\n           UPI\tUPI data traffic\n     UOPS_EXEC\tUOPs execution\n      TLB_DATA\tL2 data TLB miss rate/ratio\n        CACHES\tCache bandwidth in MBytes/s\n        DIVIDE\tDivide unit information\n           TMA\tTop down cycle allocation\n         CLOCK\tPower and Energy consumption\n      FLOPS_DP\tDouble Precision MFLOP/s\n  CYCLE_STALLS\tCycle Activities (Stalls)\n            L3\tL3 cache bandwidth in MBytes/s\n           UPI\tUPI traffic\n         L3NEW\tL3 cache bandwidth in MBytes/s\n          L3PF\tL3 cache bandwidth in MBytes/s\n          L2L3\tL3 cache bandwidth in MBytes/s","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"These groups can be passed to the command line option -g. Note that you can also query the available performance groups programmatically using LIKWID.PerfMon.supported_groups().","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Another important option is -C <list>:","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Processor ids to pin threads and measure, e.g. 1,2-4,8. For information about the <list> syntax, see likwid-pin.","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Note that cpu ids start with zero (not one).","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Combinding the points above, the full command could look like this: likwid-perfctr -C 0 -g FLOPS_DP -m julia.","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"For more information, check out the official documentation.","category":"page"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"warning: Multithreading\nIt is important to note that likwid-perfctrs built-in threading pinning through -C <cores> doesn't work as expected for Julia when using multiple threads, i.e. Threads.nthreads() > 1. Instead, one should use a different mean of pinning threads, e.g. like JULIA_EXCLUSIVE=1 or ThreadPinning.jl, and use -c <cores> (lowercase c!), which will instruct LIKWID to only measure on these cores (disables LIKWIDs pinning).","category":"page"},{"location":"marker/#API","page":"Marker API (CPU)","title":"API","text":"","category":"section"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Pages   = [\"marker.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"marker/#Functions","page":"Marker API (CPU)","title":"Functions","text":"","category":"section"},{"location":"marker/","page":"Marker API (CPU)","title":"Marker API (CPU)","text":"Modules = [LIKWID.Marker]","category":"page"},{"location":"marker/#LIKWID.Marker.close-Tuple{}","page":"Marker API (CPU)","title":"LIKWID.Marker.close","text":"Close the connection to the LIKWID Marker API and write out measurement data to file. This file will be evaluated by likwid-perfctr.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.getregion-Tuple{AbstractString}","page":"Marker API (CPU)","title":"LIKWID.Marker.getregion","text":"getregion(regiontag::AbstractString, [num_events]) -> nevents, events, time, count\n\nGet the intermediate results of the region identified by regiontag. On success, it returns     * nevents: the number of events in the current group,     * events: a list with all the aggregated event results,     * time: the measurement time for the region and     * count: the number of calls.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.init-Tuple{}","page":"Marker API (CPU)","title":"LIKWID.Marker.init","text":"Initialize the Marker API. Must be called previous to all other functions.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.init_nothreads-Tuple{}","page":"Marker API (CPU)","title":"LIKWID.Marker.init_nothreads","text":"Initialize the Marker API only on the main thread. LIKWID.Marker.threadinit() must be called manually.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.isactive-Tuple{}","page":"Marker API (CPU)","title":"LIKWID.Marker.isactive","text":"Checks whether the Marker API is active, i.e. julia has been started under likwid-perfctr -C ... -g ... -m.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.nextgroup-Tuple{}","page":"Marker API (CPU)","title":"LIKWID.Marker.nextgroup","text":"Switch to the next event set in a round-robin fashion. If you have set only one event set on the command line, this function performs no operation.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.region-Tuple{Any, AbstractString}","page":"Marker API (CPU)","title":"LIKWID.Marker.region","text":"region(f, regiontag::AbstractString)\n\nAdds a LIKWID marker region around the execution of the given function f using Marker.startregion, Marker.stopregion under the hood. Note that LIKWID.Marker.init() and LIKWID.Marker.close() must be called before and after, respectively.\n\nExamples\n\njulia> using LIKWID\n\njulia> Marker.init()\n\njulia> region(\"sleeping...\") do\n           sleep(1)\n       end\ntrue\n\njulia> region(()->rand(100), \"create rand vec\")\ntrue\n\njulia> Marker.close()\n\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.registerregion-Tuple{AbstractString}","page":"Marker API (CPU)","title":"LIKWID.Marker.registerregion","text":"Register a region with name regiontag to the Marker API. On success, true is returned.\n\nThis is an optional function to reduce the overhead of region registration at Marker.startregion. If you don't call registerregion, the registration is done at startregion.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.resetregion-Tuple{AbstractString}","page":"Marker API (CPU)","title":"LIKWID.Marker.resetregion","text":"Reset the values stored using the region name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.startregion-Tuple{AbstractString}","page":"Marker API (CPU)","title":"LIKWID.Marker.startregion","text":"Start measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.stopregion-Tuple{AbstractString}","page":"Marker API (CPU)","title":"LIKWID.Marker.stopregion","text":"Stop measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.threadinit-Tuple{}","page":"Marker API (CPU)","title":"LIKWID.Marker.threadinit","text":"Add the current thread to the Marker API.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.@region-Tuple{Any, Any}","page":"Marker API (CPU)","title":"LIKWID.Marker.@region","text":"Convenience macro for flanking code with Marker.startregion and Marker.stopregion.\n\nExamples\n\njulia> using LIKWID\n\njulia> Marker.init()\n\njulia> @region \"sleeping...\" sleep(1)\ntrue\n\njulia> @region \"create rand vec\" rand(100)\ntrue\n\njulia> Marker.close()\n\n\n\n\n\n\n","category":"macro"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"using LIKWID","category":"page"},{"location":"likwid-pin/#likwid-pin","page":"likwid-pin","title":"likwid-pin","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"Pinning threads to cores. For details, check out the official documentation.","category":"page"},{"location":"likwid-pin/#Example","page":"likwid-pin","title":"Example","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/pin.)","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"# pin.jl\nusing Base.Threads\n\nglibc_coreid() = @ccall sched_getcpu()::Cint\n\n@threads :static for i in 1:nthreads()\n    println(\"Thread: $(i), CPU: $(glibc_coreid())\")\nend","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"Running this file with e.g. likwid-pin -s 0xffffffffffffffe1 -c 1,3,5,7 julia -t 4 pin.jl one obtains","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"[pthread wrapper] \n[pthread wrapper] MAIN -> 1\n[pthread wrapper] PIN_MASK: 0->3  1->5  2->7  \n[pthread wrapper] SKIP MASK: 0xFFFFFFFFFFFFFFE1\n\tthreadid 140576878921280 -> SKIP \n\tthreadid 140576612378176 -> hwthread 3 - OK\n\tthreadid 140576590759488 -> hwthread 5 - OK\n\tthreadid 140576494188096 -> hwthread 7 - OK\nThread: 1, CPU: 1\nThread: 2, CPU: 3\nThread: 3, CPU: 5\nThread: 4, CPU: 7","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"If you're wondering about the -s 0xffffffffffffffe1 option, see Mask below.","category":"page"},{"location":"likwid-pin/#Mask","page":"likwid-pin","title":"Mask","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"(See this discussion on the Julia discourse.)","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"In general, likwid-pin pins all pthread-threads. However, julia involves more than the \"Julia user threads\" specified via the -t option. For example, it create an additional unix signal thread (in src/signals-unix.c) and - unless OPENBLAS_NUM_THREADS=1 - the OpenBLAS related threads (blas_thread_init () in [..]/lib/julia/libopenblas64_.so). Hence, when you run likwid-pin -c 0-3 julia -t 4 the four cores (0-3) are actually oversubscribed and multiple \"Julia user threads\" get pinned to the same core.","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"To work around this, we need to provide a mask to likwid-pin via the -s option. To compute an appropriate mask for N \"Julia user threads\" you may use the helper function LIKWID.pinmask(N):","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"LIKWID.pinmask(4)","category":"page"},{"location":"likwid-pin/#Functions","page":"likwid-pin","title":"Functions","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"LIKWID.pinmask","category":"page"},{"location":"likwid-pin/#LIKWID.pinmask","page":"likwid-pin","title":"LIKWID.pinmask","text":"pinmask(N::Integer) -> mask\n\nGenerates a mask that can be supplied to likwid pin -s <mask> to pin N Julia threads.\n\nTaken from https://discourse.julialang.org/t/thread-affinitization-pinning-julia-threads-to-cores/58069/8.\n\n\n\n\n\n","category":"function"},{"location":"marker_gpu/#Marker-API-(GPU)","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"","category":"section"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"Note: This is a maturing feature. Only NVIDIA GPUs are supported.","category":"page"},{"location":"marker_gpu/#Example","page":"Marker API (GPU)","title":"Example","text":"","category":"section"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/perfctr_gpu.)","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"# perfctr_gpu.jl\nusing LIKWID\nusing LinearAlgebra\nusing CUDA\n\n@assert CUDA.functional()\n\nGPUMarker.init()\n\n# Note: CUDA defaults to Float32\nAgpu = CUDA.rand(128, 64)\nBgpu = CUDA.rand(64, 128)\nCgpu = CUDA.zeros(128, 128)\n\nGPUMarker.startregion(\"matmul\")\nfor _ in 1:100\n    mul!(Cgpu, Agpu, Bgpu)\nend\nGPUMarker.stopregion(\"matmul\")\n\nGPUMarker.close()","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"Running this file with the command likwid-perfctr -G 0 -W FLOPS_SP -m julia perfctr_gpu.jl one should obtain something like the following:","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6246 CPU @ 3.30GHz\nCPU type:\tIntel Cascadelake SP processor\nCPU clock:\t3.30 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion matmul, Group 1: FLOPS_SP\n+-------------------+----------+\n|    Region Info    |   GPU 0  |\n+-------------------+----------+\n| RDTSC Runtime [s] | 3.426146 |\n|     call count    |        1 |\n+-------------------+----------+\n+----------------------------------------------------+---------+----------+\n|                        Event                       | Counter |   GPU 0  |\n+----------------------------------------------------+---------+----------+\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FADD_PRED_ON_SUM |   GPU0  |  2457600 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FMUL_PRED_ON_SUM |   GPU1  |  3276800 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FFMA_PRED_ON_SUM |   GPU2  | 52436990 |\n+----------------------------------------------------+---------+----------+\n+---------------------+---------+\n|        Metric       |  GPU 0  |\n+---------------------+---------+\n| Runtime (RDTSC) [s] |  3.4261 |\n|     SP [MFLOP/s]    | 32.2836 |\n+---------------------+---------+","category":"page"},{"location":"marker_gpu/#Convenience-macro","page":"Marker API (GPU)","title":"Convenience macro","text":"","category":"section"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"We provide (and export) the macro @gpuregion which can be used to write regions like","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"GPUMarker.startregion(\"matmul\")\nfor _ in 1:100\n    mul!(Cgpu, Agpu, Bgpu)\nend\nGPUMarker.stopregion(\"matmul\")","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"simply as","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"@gpuregion \"matmul\" for _ in 1:100\n    mul!(Cgpu, Agpu, Bgpu)\nend","category":"page"},{"location":"marker_gpu/#likwid-perfctr-in-a-nutshell","page":"Marker API (GPU)","title":"likwid-perfctr in a nutshell","text":"","category":"section"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"Most importantly, as for CPUs, you need to use the -m option to activate the marker API.","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"To list the available GPU performance groups, run likwid-perfctr -a and look for the lower \"NvMon\" table:","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"[...]\n\nNvMon group name\tDescription\n--------------------------------------------------------------------------------\n    DATA\tLoad to store ratio\nFLOPS_SP\tSingle-precision floating point\nFLOPS_HP\tHalf-precision floating point\nFLOPS_DP\tDouble-precision floating point","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"These groups can be passed to the command line option -W. Note that you can also query the available GPU performance groups programmatically using NvMon.supported_groups(gpuid::Integer).","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"Another important option is -G <list>, where <list> is a list of GPUs to monitor. Note that GPU ids start with zero (not one).","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"Combinding the points above, the full command could look like this: likwid-perfctr -G 0 -W FLOPS_SP -m julia.","category":"page"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"For more information, check out the official documentation.","category":"page"},{"location":"marker_gpu/#API","page":"Marker API (GPU)","title":"API","text":"","category":"section"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"Pages   = [\"marker_gpu.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"marker_gpu/#Functions","page":"Marker API (GPU)","title":"Functions","text":"","category":"section"},{"location":"marker_gpu/","page":"Marker API (GPU)","title":"Marker API (GPU)","text":"Modules = [LIKWID.GPUMarker]","category":"page"},{"location":"marker_gpu/#LIKWID.GPUMarker.close-Tuple{}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.close","text":"Close the connection to the LIKWID GPU Marker API and write out measurement data to file. This file will be evaluated by likwid-perfctr.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.getregion-Tuple{AbstractString}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.getregion","text":"getregion(regiontag::AbstractString) -> nevents, events, time, count\n\nGet the intermediate results of the region identified by regiontag. On success, it returns     * nevents: the number of events in the current group,     * events: a list with all the aggregated event results,     * time: the measurement time for the region and     * count: the number of calls.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.gpuregion-Tuple{Any, AbstractString}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.gpuregion","text":"gpuregion(f, regiontag::AbstractString)\n\nAdds a LIKWID GPU marker region around the execution of the given function f using GPUMarker.startregion, GPUMarker.stopregion under the hood. Note that LIKWID.GPUMarker.init() and LIKWID.GPUMarker.close() must be called before and after, respectively.\n\nExamples\n\njulia> using LIKWID, CUDA\n\njulia> GPUMarker.init()\n\njulia> gpuregion(\"sleeping...\") do\n           sleep(1)\n       end\ntrue\n\njulia> gpuregion(()->CUDA.rand(100), \"create rand vec\")\ntrue\n\njulia> GPUMarker.close()\n\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.init-Tuple{}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.init","text":"Initialize the NvMon Marker API of the LIKWID library. Must be called previous to all other functions.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.isactive-Tuple{}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.isactive","text":"Checks whether the NVIDIA GPU Marker API is active, i.e. julia has been started under likwid-perfctr -G ... -W ... -m.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.nextgroup-Tuple{}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.nextgroup","text":"Switch to the next event set in a round-robin fashion. If you have set only one event set on the command line, this function performs no operation.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.registerregion-Tuple{AbstractString}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.registerregion","text":"Register a region with name regiontag to the GPU Marker API. On success, true is returned.\n\nThis is an optional function to reduce the overhead of region registration at Marker.startregion. If you don't call registerregion, the registration is done at startregion.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.resetregion-Tuple{AbstractString}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.resetregion","text":"Reset the values stored using the region name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.startregion-Tuple{AbstractString}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.startregion","text":"Start measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.stopregion-Tuple{AbstractString}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.stopregion","text":"Stop measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.@gpuregion-Tuple{Any, Any}","page":"Marker API (GPU)","title":"LIKWID.GPUMarker.@gpuregion","text":"Convenience macro for flanking code with GPUMarker.startregion and GPUMarker.stopregion.\n\nExamples\n\njulia> using LIKWID, CUDA\n\njulia> GPUMarker.init()\n\njulia> @gpuregion \"sleeping...\" sleep(1)\ntrue\n\njulia> @gpuregion \"create rand vec\" CUDA.rand(100)\ntrue\n\njulia> GPUMarker.close()\n\n\n\n\n\n\n","category":"macro"},{"location":"#LIKWID-Like-I-Knew-What-I'm-Doing","page":"LIKWID","title":"LIKWID - Like I Knew What I'm Doing","text":"","category":"section"},{"location":"","page":"LIKWID","title":"LIKWID","text":"LIKWID.jl is a Julia wrapper for the  performance monitoring and benchmarking suite LIKWID.","category":"page"},{"location":"#Installation","page":"LIKWID","title":"Installation","text":"","category":"section"},{"location":"","page":"LIKWID","title":"LIKWID","text":"Prerequisites:","category":"page"},{"location":"","page":"LIKWID","title":"LIKWID","text":"You must have likwid installed (see the build & install instructions).\nYou must be running Linux. (LIKWID doesn't support macOS or Windows.)","category":"page"},{"location":"","page":"LIKWID","title":"LIKWID","text":"LIKWID.jl is a registered Julia package. Hence, you can simply add it to your Julia environment with the command","category":"page"},{"location":"","page":"LIKWID","title":"LIKWID","text":"] add LIKWID","category":"page"},{"location":"#LIKWID.jl-vs-LinuxPerf.jl","page":"LIKWID","title":"LIKWID.jl vs LinuxPerf.jl","text":"","category":"section"},{"location":"","page":"LIKWID","title":"LIKWID","text":"As per default (and recommendation) LIKWID(.jl) uses a custom access daemon to monitor hardware performance counters. In contrast, LinuxPerf.jl uses Linux's perf_events. However, it is possible to make LIKWID use perf_events as an alternative (inferior) backend. See here for more information.","category":"page"},{"location":"#Supported-CPUs","page":"LIKWID","title":"Supported CPUs","text":"","category":"section"},{"location":"","page":"LIKWID","title":"LIKWID","text":"using LIKWID","category":"page"},{"location":"","page":"LIKWID","title":"LIKWID","text":"LIKWID.print_supported_cpus()\nLibc.flush_cstdio() # hide","category":"page"},{"location":"nvmon/#NVIDIA-Monitoring-(NvMon)","page":"NVIDIA monitoring","title":"NVIDIA Monitoring (NvMon)","text":"","category":"section"},{"location":"nvmon/","page":"NVIDIA monitoring","title":"NVIDIA monitoring","text":"Note: This is a maturing feature. Only NVIDIA GPUs are supported.","category":"page"},{"location":"nvmon/#API","page":"NVIDIA monitoring","title":"API","text":"","category":"section"},{"location":"nvmon/","page":"NVIDIA monitoring","title":"NVIDIA monitoring","text":"Pages   = [\"nvmon.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"nvmon/#Functions","page":"NVIDIA monitoring","title":"Functions","text":"","category":"section"},{"location":"nvmon/","page":"NVIDIA monitoring","title":"NVIDIA monitoring","text":"Modules = [LIKWID.NvMon]","category":"page"},{"location":"nvmon/#LIKWID.NvMon.add_event_set-Tuple{AbstractString}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.add_event_set","text":"add_event_set(estr) -> groupid\n\nAdd a performance group or a custom event set to the nvmon module. Returns a groupid (starting at 1) which is required to later specify the event set.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_id_of_active_group-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_id_of_active_group","text":"Return the groupid of the currently activate group.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_last_metric-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_last_metric","text":"Return the derived metric result of the last measurement cycle identified by group groupid and the indices for metric metricidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_last_result-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_last_result","text":"Return the raw counter register result of the last measurement cycle identified by group groupid and the indices for event eventidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_longinfo_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_longinfo_of_group","text":"Return the (long) description of a performance group with id groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_metric-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_metric","text":"Return the derived metric result of all measurements identified by group groupid and the indices for metric metricidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_counter-Tuple{Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_counter","text":"Return the name of the counter register identified by groupid and eventidx (both start at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_event-Tuple{Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_event","text":"Return the name of the event identified by groupid and eventidx (both start at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_group","text":"Return the name of the group identified by groupid (starts at 1). If it is a custom event set, the name is set to Custom.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_metric-Tuple{Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_metric","text":"Return the name of a derived metric identified by groupid and metricidx (both start at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_events-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_events","text":"Return the number of events in the group with id groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_gpus-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_gpus","text":"Return the number of GPUs initialized in the nvmon module.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_groups-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_groups","text":"Return the number of groups currently registered in the nvmon module.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_metrics-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_metrics","text":"Return the number of metrics in the group with id groupid (starts at 1). Always zero for custom event sets.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_result-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_result","text":"Return the raw counter register result of all measurements identified by group groupid and the indices for event eventidx and thread threadidx (all starting at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_shortinfo_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_shortinfo_of_group","text":"Return the short information about a performance group with id groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_time_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_time_of_group","text":"Return the measurement time for group identified by groupid (starts at 1).\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.isgroupsupported","page":"NVIDIA monitoring","title":"LIKWID.NvMon.isgroupsupported","text":"Checks if the given performance group is available on the given GPU (defaults to the first).\n\n\n\n\n\n","category":"function"},{"location":"nvmon/#LIKWID.NvMon.read_counters-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.read_counters","text":"Read the counter registers. To be executed after start_counters and before stop_counters. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.setup_counters-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.setup_counters","text":"Program the counter registers to measure all events in group groupid (starts at 1). Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.start_counters-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.start_counters","text":"Start the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.stop_counters-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.stop_counters","text":"Stop the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.supported_groups","page":"NVIDIA monitoring","title":"LIKWID.NvMon.supported_groups","text":"Return a list of all available nvmon groups for the GPU identified by gpuid (starts at 1).\n\nExamples\n\njulia> NvMon.supported_groups()\n4-element Vector{LIKWID.GroupInfoCompact}:\n DATA => Load to store ratio\n FLOPS_SP => Single-precision floating point\n FLOPS_HP => Half-precision floating point\n FLOPS_DP => Double-precision floating point\n\n\n\n\n\n","category":"function"},{"location":"nvmon/#LIKWID.NvMon.switch_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.switch_group","text":"Switch currently active group to groupid (starts at 1). Returns true on success.\n\n\n\n\n\n","category":"method"}]
}
