var documenterSearchIndex = {"docs":
[{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"using LIKWID","category":"page"},{"location":"power/#Power-/-Energy","page":"Power / Energy","title":"Power / Energy","text":"","category":"section"},{"location":"power/#Example","page":"Power / Energy","title":"Example","text":"","category":"section"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"General power information:","category":"page"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"power = LIKWID.Power.get_power_info()\npower.domains\nfirst(power.domains)","category":"page"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"Energy measurement:","category":"page"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"LIKWID.Power.measure(; cpuid=0, domainid=0) do\n    sleep(1)\nend\nLIKWID.Power.measure(; cpuid=0, domainid=0) do\n    sum(sin(rand()) for _ in 1:1_000_000)\nend","category":"page"},{"location":"power/#Functions","page":"Power / Energy","title":"Functions","text":"","category":"section"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"LIKWID.Power.init\nLIKWID.Power.finalize\nLIKWID.Power.get_power_info\nLIKWID.Power.start_power\nLIKWID.Power.stop_power\nLIKWID.Power.get_power\nLIKWID.Power.measure","category":"page"},{"location":"power/#LIKWID.Power.init","page":"Power / Energy","title":"LIKWID.Power.init","text":"Initialize power measurements for the given CPU. Returns the RAPL status, i.e. false (no RAPL) or true (RAPL working).\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.finalize","page":"Power / Energy","title":"LIKWID.Power.finalize","text":"Finalize power measurements.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.get_power_info","page":"Power / Energy","title":"LIKWID.Power.get_power_info","text":"get_power_info() -> LIKWID.PowerInfo\n\nGet power / energy information.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.start_power","page":"Power / Energy","title":"LIKWID.Power.start_power","text":"Return the start value for a cpu (cpuid) for the domain with domainid.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.stop_power","page":"Power / Energy","title":"LIKWID.Power.stop_power","text":"Return the stop value for a cpu (cpuid) for the domain with domainid.\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.get_power","page":"Power / Energy","title":"LIKWID.Power.get_power","text":"get_power(p_start::Integer, p_stop::Integer, domainid::Integer)\n\nCalculate the μJ from the values retrieved by start_power() and stop_power().\n\n\n\n\n\n","category":"function"},{"location":"power/#LIKWID.Power.measure","page":"Power / Energy","title":"LIKWID.Power.measure","text":"measure(f; cpuid::Integer=0, domainid::Integer)\n\nMeasure / calculate the energy for the given cpuid and domainid over the execution of the function f using Power.start_power, Power.stop_power, etc. under the hood. Automatically initializes and finalizes the power module.\n\nExamples\n\njulia> LIKWID.Power.measure(; cpuid=0, domainid=0) do\n           sleep(1)\n       end\n15.13702392578125 μJ\n\n\n\n\n\n","category":"function"},{"location":"power/#Types","page":"Power / Energy","title":"Types","text":"","category":"section"},{"location":"power/","page":"Power / Energy","title":"Power / Energy","text":"LIKWID.PowerInfo\nLIKWID.PowerDomain\nLIKWID.LibLikwid.PowerType\nLIKWID.TurboBoost","category":"page"},{"location":"power/#LIKWID.PowerInfo","page":"Power / Energy","title":"LIKWID.PowerInfo","text":"Power information\n\n\n\n\n\n","category":"type"},{"location":"power/#LIKWID.PowerDomain","page":"Power / Energy","title":"LIKWID.PowerDomain","text":"Power domain information\n\n\n\n\n\n","category":"type"},{"location":"power/#LIKWID.LibLikwid.PowerType","page":"Power / Energy","title":"LIKWID.LibLikwid.PowerType","text":"Different types of power domains\n\n\n\n\n\n","category":"type"},{"location":"power/#LIKWID.TurboBoost","page":"Power / Energy","title":"LIKWID.TurboBoost","text":"Turbo boost information\n\n\n\n\n\n","category":"type"},{"location":"examples/saxpy/#SAXPY-CPUGPU","page":"SAXPY CPU+GPU","title":"SAXPY CPU+GPU","text":"","category":"section"},{"location":"examples/saxpy/","page":"SAXPY CPU+GPU","title":"SAXPY CPU+GPU","text":"Example that demonstrates using the CPU and GPU Marker API together in one application.","category":"page"},{"location":"examples/saxpy/","page":"SAXPY CPU+GPU","title":"SAXPY CPU+GPU","text":"# saxpy.jl\nusing LIKWID\nusing CUDA\nusing LinearAlgebra\n\n@assert CUDA.functional()\n\nN = 100_000_000\na = 3.141f0\nz = zeros(Float32, N)\nx = rand(Float32, N)\ny = rand(Float32, N)\n\nz_gpu = CUDA.zeros(Float32, N)\nx_gpu = CUDA.rand(Float32, N)\ny_gpu = CUDA.rand(Float32, N)\n\nfunction saxpy_cpu!(z,a,x,y)\n    z .= a .* x .+ y\nend\n\nfunction saxpy_gpu!(z,a,x,y)\n    CUDA.@sync z .= a .* x .+ y\nend\n\nLIKWID.Marker.init()\nLIKWID.GPUMarker.init()\n\nsaxpy_cpu!(z,a,x,y)\nLIKWID.Marker.startregion(\"saxpy_cpu\")\nsaxpy_cpu!(z,a,x,y)\nLIKWID.Marker.stopregion(\"saxpy_cpu\")\n\nsaxpy_gpu!(z_gpu,a,x_gpu,y_gpu)\nLIKWID.GPUMarker.startregion(\"saxpy_gpu\")\nsaxpy_gpu!(z_gpu,a,x_gpu,y_gpu)\nLIKWID.GPUMarker.stopregion(\"saxpy_gpu\")\n\nLIKWID.Marker.close()\nLIKWID.GPUMarker.close()","category":"page"},{"location":"examples/saxpy/","page":"SAXPY CPU+GPU","title":"SAXPY CPU+GPU","text":"Possible output:","category":"page"},{"location":"examples/saxpy/","page":"SAXPY CPU+GPU","title":"SAXPY CPU+GPU","text":"--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6246 CPU @ 3.30GHz\nCPU type:\tIntel Cascadelake SP processor\nCPU clock:\t3.30 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion saxpy_cpu, Group 1: FLOPS_SP\n+-------------------+------------+\n|    Region Info    | HWThread 0 |\n+-------------------+------------+\n| RDTSC Runtime [s] |   0.090796 |\n|     call count    |          1 |\n+-------------------+------------+\n+------------------------------------------+---------+------------+\n|                   Event                  | Counter | HWThread 0 |\n+------------------------------------------+---------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  |   59866700 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  |  344927500 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  |  298780700 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_SINGLE |   PMC0  |          0 |\n|    FP_ARITH_INST_RETIRED_SCALAR_SINGLE   |   PMC1  |        111 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_SINGLE |   PMC2  |   25000000 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_SINGLE |   PMC3  |          0 |\n+------------------------------------------+---------+------------+\n+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.0908 |\n| Runtime unhalted [s] |     0.1045 |\n|      Clock [MHz]     |  3809.5859 |\n|          CPI         |     5.7616 |\n|     SP [MFLOP/s]     |  2202.7354 |\n|   AVX SP [MFLOP/s]   |  2202.7341 |\n|  AVX512 SP [MFLOP/s] |          0 |\n|   Packed [MUOPS/s]   |   275.3418 |\n|   Scalar [MUOPS/s]   |     0.0012 |\n|  Vectorization ratio |    99.9996 |\n+----------------------+------------+\nRegion saxpy_gpu, Group 1: FLOPS_SP\n+-------------------+----------+\n|    Region Info    |   GPU 0  |\n+-------------------+----------+\n| RDTSC Runtime [s] | 0.010824 |\n|     call count    |        1 |\n+-------------------+----------+\n+----------------------------------------------------+---------+-----------+\n|                        Event                       | Counter |   GPU 0   |\n+----------------------------------------------------+---------+-----------+\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FADD_PRED_ON_SUM |   GPU0  |         0 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FMUL_PRED_ON_SUM |   GPU1  |         0 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FFMA_PRED_ON_SUM |   GPU2  | 100000000 |\n+----------------------------------------------------+---------+-----------+\n+---------------------+------------+\n|        Metric       |    GPU 0   |\n+---------------------+------------+\n| Runtime (RDTSC) [s] |     0.0108 |\n|     SP [MFLOP/s]    | 18477.1502 |\n+---------------------+------------+","category":"page"},{"location":"access/","page":"HPM / Access","title":"HPM / Access","text":"using LIKWID","category":"page"},{"location":"access/#HPM-/-Access","page":"HPM / Access","title":"HPM / Access","text":"","category":"section"},{"location":"access/#Functions","page":"HPM / Access","title":"Functions","text":"","category":"section"},{"location":"access/","page":"HPM / Access","title":"HPM / Access","text":"Modules = [LIKWID.HPM]","category":"page"},{"location":"access/#LIKWID.HPM.add_thread-Tuple{Any}","page":"HPM / Access","title":"LIKWID.HPM.add_thread","text":"Add the given CPU to the access module. This opens the commnunication to either the MSR/PCI files or the access daemon.\n\n\n\n\n\n","category":"method"},{"location":"access/#LIKWID.HPM.finalize-Tuple{}","page":"HPM / Access","title":"LIKWID.HPM.finalize","text":"Close the connections to the MSR/PCI files or the access daemon.\n\n\n\n\n\n","category":"method"},{"location":"access/#LIKWID.HPM.init-Tuple{}","page":"HPM / Access","title":"LIKWID.HPM.init","text":"Initialize the access module internals to either the MSR/PCI files or the access daemon\n\n\n\n\n\n","category":"method"},{"location":"access/#LIKWID.HPM.mode-Tuple{Union{LIKWID.LibLikwid.AccessMode, Integer}}","page":"HPM / Access","title":"LIKWID.HPM.mode","text":"Sets the mode how the MSR and PCI registers should be accessed. Available options:\n\n0 or LibLikwid.ACCESSMODE_DIRECT: direct access (propably root priviledges required)\n1 or LibLikwid.ACCESSMODE_DAEMON: accesses through the access daemon\n\nMust be called before HPM.init.\n\n\n\n\n\n","category":"method"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"using LIKWID","category":"page"},{"location":"timer/#CPU-Clock-Timer","page":"CPU clock timer","title":"CPU Clock Timer","text":"","category":"section"},{"location":"timer/#Example","page":"CPU clock timer","title":"Example","text":"","category":"section"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"Timing is as simple as","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"LIKWID.Timer.@timeit sleep(1)","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"Apart from the time it took to execute sleep(1) (clock) one also gets the number of CPU clock cycles corresponding to the time interval (cycles).","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"Note that the macro usage above is essentially equivalent to the following manual sequence","category":"page"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"LIKWID.Timer.init()\nt_start = LIKWID.Timer.start_clock()\nsleep(1)\nt_stop = LIKWID.Timer.stop_clock(t_start)\nLIKWID.Timer.get_clock(t_stop)\nLIKWID.Timer.get_clock_cycles(t_stop)\nLIKWID.Timer.finalize()","category":"page"},{"location":"timer/#Functions","page":"CPU clock timer","title":"Functions","text":"","category":"section"},{"location":"timer/","page":"CPU clock timer","title":"CPU clock timer","text":"LIKWID.Timer.init\nLIKWID.Timer.finalize\nLIKWID.Timer.get_cpu_clock\nLIKWID.Timer.get_cpu_clock_current\nLIKWID.Timer.start_clock\nLIKWID.Timer.stop_clock\nLIKWID.Timer.get_clock\nLIKWID.Timer.get_clock_cycles\nLIKWID.Timer.timeit\nLIKWID.Timer.@timeit","category":"page"},{"location":"timer/#LIKWID.Timer.init","page":"CPU clock timer","title":"LIKWID.Timer.init","text":"Initialize LIKWIDs timer module\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.finalize","page":"CPU clock timer","title":"LIKWID.Timer.finalize","text":"Close and finalize LIKWIDs timer module\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_cpu_clock","page":"CPU clock timer","title":"LIKWID.Timer.get_cpu_clock","text":"Return the CPU clock determined at Timer.init().\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_cpu_clock_current","page":"CPU clock timer","title":"LIKWID.Timer.get_cpu_clock_current","text":"Return the current CPU clock read from sysfs\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.start_clock","page":"CPU clock timer","title":"LIKWID.Timer.start_clock","text":"Start the clock and return a LibLikwid.TimerData object including the start timestamp.\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.stop_clock","page":"CPU clock timer","title":"LIKWID.Timer.stop_clock","text":"stop_clock(timer::LibLikwid.TimerData) -> newtimer::LibLikwid.TimerData\n\nStop the clock and return a LibLikwid.TimerData object including the start and stop timestamps. The input timer should be the output of Timer.start_clock().\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_clock","page":"CPU clock timer","title":"LIKWID.Timer.get_clock","text":"get_clock(timer::LibLikwid.TimerData)\n\nReturn the measured interval in seconds for the given timer. The input timer should be the output of Timer.stop_clock.\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.get_clock_cycles","page":"CPU clock timer","title":"LIKWID.Timer.get_clock_cycles","text":"get_clock_cycles(timer::LibLikwid.TimerData)\n\nReturn the measured interval in cycles for the given timer. The input timer should be the output of Timer.stop_clock.\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.timeit","page":"CPU clock timer","title":"LIKWID.Timer.timeit","text":"timeit(f)\n\nTime the given function f using Timer.start_clock, Timer.stop_clock, etc. under the hood. Automatically initializes and finalizes the timer module.\n\nExamples\n\njulia> LIKWID.Timer.timeit() do\n           sleep(1)\n       end\n(clock = 1.0008815780376372, cycles = 3603224844)\n\n\n\n\n\n","category":"function"},{"location":"timer/#LIKWID.Timer.@timeit","page":"CPU clock timer","title":"LIKWID.Timer.@timeit","text":"Convenience macro for Timer.timeit.\n\nExamples\n\njulia> LIKWID.Timer.@timeit sleep(1)\n(clock = 1.0008815780376372, cycles = 3603224844)\n\n\n\n\n\n","category":"macro"},{"location":"perfmon/#Performance-Monitoring-(PerfMon)","page":"Performance monitoring","title":"Performance Monitoring (PerfMon)","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"The basis functionality of likwid-perfctr.","category":"page"},{"location":"perfmon/#Example","page":"Performance monitoring","title":"Example","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/perfmon.)","category":"page"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"# perfmon.jl\nusing LIKWID\nusing LinearAlgebra\n\nA = rand(128, 64)\nB = rand(64, 128)\nC = zeros(128, 128)\n\ncpu = 0 # starts with zero!\nLIKWID.PerfMon.init(cpu)\ngroupid = LIKWID.PerfMon.add_event_set(\"FLOPS_DP\")\nLIKWID.PerfMon.setup_counters(groupid)\n\nLIKWID.PerfMon.start_counters()\nfor _ in 1:100\n    mul!(C, A, B)\nend\nLIKWID.PerfMon.stop_counters()\n\nmdict = LIKWID.PerfMon.get_metric_results(groupid, cpu)\ndisplay(mdict)\nprintln(); flush(stdout);\nedict = LIKWID.PerfMon.get_event_results(groupid, cpu)\ndisplay(edict)\n\nLIKWID.PerfMon.finalize()","category":"page"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"Running the above with julia perfmon.jl one obtains (modulo architectural differences):","category":"page"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"OrderedCollections.OrderedDict{String, Float64} with 10 entries:\n  \"Runtime (RDTSC) [s]\" => 0.695678\n  \"Runtime unhalted [s]\" => 0.0014145\n  \"Clock [MHz]\" => 1200.12\n  \"CPI\" => 1.00722\n  \"DP [MFLOP/s]\" => 38.2706\n  \"AVX DP [MFLOP/s]\" => 38.2706\n  \"AVX512 DP [MFLOP/s]\" => 38.2706\n  \"Packed [MUOPS/s]\" => 4.78382\n  \"Scalar [MUOPS/s]\" => 0.0\n  \"Vectorization ratio\" => 100.0\nOrderedCollections.OrderedDict{String, Float64} with 7 entries:\n  \"INSTR_RETIRED_ANY\" => 4.63437e6\n  \"CPU_CLK_UNHALTED_CORE\" => 4.66782e6\n  \"CPU_CLK_UNHALTED_REF\" => 1.28352e7\n  \"FP_ARITH_INST_RETIRED_128B_PACKED_DOUBLE\" => 0.0\n  \"FP_ARITH_INST_RETIRED_SCALAR_DOUBLE\" => 0.0\n  \"FP_ARITH_INST_RETIRED_256B_PACKED_DOUBLE\" => 0.0\n  \"FP_ARITH_INST_RETIRED_512B_PACKED_DOUBLE\" => 3.328e6","category":"page"},{"location":"perfmon/#Functions","page":"Performance monitoring","title":"Functions","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"Modules = [LIKWID.PerfMon]","category":"page"},{"location":"perfmon/#LIKWID.PerfMon.add_event_set-Tuple{AbstractString}","page":"Performance monitoring","title":"LIKWID.PerfMon.add_event_set","text":"add_event_set(estr) -> groupid\n\nAdd a performance group or a custom event set to the perfmon module. Returns a groupid which is required to later specify the event set.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_event_results-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_event_results","text":"Get the name and results of all events of a given group for a given cpu thread.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_groups-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_groups","text":"Return a list of all available perfmon groups.\n\nExamples\n\njulia> LIKWID.PerfMon.get_groups()\n30-element Vector{LIKWID.GroupInfoCompact}:\n MEM_SP => Overview of arithmetic and main memory performance\n CYCLE_ACTIVITY => Cycle Activities\n ENERGY => Power and Energy consumption\n UOPS_RETIRE => UOPs retirement\n PMM => Intel Optane DC bandwidth in MBytes/s\n TLB_INSTR => L1 Instruction TLB miss rate/ratio\n DATA => Load to store ratio\n UOPS_ISSUE => UOPs issueing\n L2CACHE => L2 cache miss rate/ratio\n L2 => L2 cache bandwidth in MBytes/s\n ⋮\n TMA => Top down cycle allocation\n CLOCK => Power and Energy consumption\n FLOPS_DP => Double Precision MFLOP/s\n CYCLE_STALLS => Cycle Activities (Stalls)\n L3 => L3 cache bandwidth in MBytes/s\n UPI => UPI traffic\n L3NEW => L3 cache bandwidth in MBytes/s\n L3PF => L3 cache bandwidth in MBytes/s\n L2L3 => L3 cache bandwidth in MBytes/s\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_id_of_active_group-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_id_of_active_group","text":"Return the groupid of the currently activate group.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_last_metric-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_last_metric","text":"Return the derived metric result of the last measurement cycle identified by group groupid and the indices for metric metricidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_last_result-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_last_result","text":"Return the raw counter register result of the last measurement cycle identified by group groupid and the indices for event eventidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_longinfo_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_longinfo_of_group","text":"Return the (long) description of a performance group.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_metric-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_metric","text":"Return the derived metric result of all measurements identified by group groupid and the indices for metric metricidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_metric_results-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_metric_results","text":"Get the name and results of all metrics of a given group for a given cpu thread.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_counter-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_counter","text":"Return the name of the counter register identified by groupid and eventidx.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_event-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_event","text":"Return the name of the event identified by groupid and eventidx.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_group","text":"Return the name of the group identified by groupid. If it is a custom event set, the name is set to Custom.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_name_of_metric-Tuple{Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_name_of_metric","text":"Return the name of a derived metric identified by groupid and metricidx.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_events-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_events","text":"Return the amount of events in the group.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_groups-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_groups","text":"Return the number of groups currently registered in the perfmon module.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_metrics-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_metrics","text":"Return the amount of metrics in the group. Always zero for custom event sets.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_number_of_threads-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_number_of_threads","text":"Return the number of threads initialized in the perfmon module.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_result-Tuple{Integer, Integer, Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_result","text":"Return the raw counter register result of all measurements identified by group groupid and the indices for event eventidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_shortinfo_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_shortinfo_of_group","text":"Return the short information about a performance group.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.get_time_of_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.get_time_of_group","text":"Return the measurement time for group identified by groupid.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.list_metrics-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.list_metrics","text":"List all the metrics of a given group.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.read_counters-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.read_counters","text":"Read the counter registers. To be executed after start_counters and before stop_counters. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.setup_counters-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.setup_counters","text":"Program the counter registers to measure all events in group groupid. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.start_counters-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.start_counters","text":"Start the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.stop_counters-Tuple{}","page":"Performance monitoring","title":"LIKWID.PerfMon.stop_counters","text":"Stop the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#LIKWID.PerfMon.switch_group-Tuple{Integer}","page":"Performance monitoring","title":"LIKWID.PerfMon.switch_group","text":"Switch currently active group to groupid. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"perfmon/#Types","page":"Performance monitoring","title":"Types","text":"","category":"section"},{"location":"perfmon/","page":"Performance monitoring","title":"Performance monitoring","text":"LIKWID.GroupInfoCompact","category":"page"},{"location":"perfmon/#LIKWID.GroupInfoCompact","page":"Performance monitoring","title":"LIKWID.GroupInfoCompact","text":"Essential information about a performance group\n\n\n\n\n\n","category":"type"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"using LIKWID","category":"page"},{"location":"affinity/#Affinity","page":"Affinity","title":"Affinity","text":"","category":"section"},{"location":"affinity/#Example","page":"Affinity","title":"Example","text":"","category":"section"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"Query affinity domain information:","category":"page"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"aff = LIKWID.get_affinity()\naff.domains","category":"page"},{"location":"affinity/#Functions","page":"Affinity","title":"Functions","text":"","category":"section"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"LIKWID.init_affinity\nLIKWID.finalize_affinity\nLIKWID.get_affinity\nLIKWID.cpustr_to_cpulist","category":"page"},{"location":"affinity/#LIKWID.init_affinity","page":"Affinity","title":"LIKWID.init_affinity","text":"Initialize LIKWIDs affinity domain module.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.finalize_affinity","page":"Affinity","title":"LIKWID.finalize_affinity","text":"Close and finalize LIKWIDs affinity domain module.\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.get_affinity","page":"Affinity","title":"LIKWID.get_affinity","text":"Query affinity domain information\n\n\n\n\n\n","category":"function"},{"location":"affinity/#LIKWID.cpustr_to_cpulist","page":"Affinity","title":"LIKWID.cpustr_to_cpulist","text":"Transform a valid cpu string in LIKWID syntax into a list of CPU IDs\n\n\n\n\n\n","category":"function"},{"location":"affinity/#Types","page":"Affinity","title":"Types","text":"","category":"section"},{"location":"affinity/","page":"Affinity","title":"Affinity","text":"LIKWID.AffinityDomains\nLIKWID.AffinityDomain","category":"page"},{"location":"affinity/#LIKWID.AffinityDomains","page":"Affinity","title":"LIKWID.AffinityDomains","text":"Information about the affinity domains\n\n\n\n\n\n","category":"type"},{"location":"affinity/#LIKWID.AffinityDomain","page":"Affinity","title":"LIKWID.AffinityDomain","text":"An affinity domain\n\n\n\n\n\n","category":"type"},{"location":"topo_gpu/","page":"GPU Topology","title":"GPU Topology","text":"using LIKWID","category":"page"},{"location":"topo_gpu/#GPU-Topology","page":"GPU Topology","title":"GPU Topology","text":"","category":"section"},{"location":"topo_gpu/#Example","page":"GPU Topology","title":"Example","text":"","category":"section"},{"location":"topo_gpu/","page":"GPU Topology","title":"GPU Topology","text":"Query GPU topology information:","category":"page"},{"location":"topo_gpu/","page":"GPU Topology","title":"GPU Topology","text":"topo = LIKWID.get_gpu_topology()\ntopo.devices\ngpu = first(topo.devices)","category":"page"},{"location":"topo_gpu/#Functions","page":"GPU Topology","title":"Functions","text":"","category":"section"},{"location":"topo_gpu/","page":"GPU Topology","title":"GPU Topology","text":"LIKWID.init_topology_gpu()\nLIKWID.finalize_topology_gpu()\nLIKWID.get_gpu_topology()","category":"page"},{"location":"topo_gpu/#LIKWID.init_topology_gpu-Tuple{}","page":"GPU Topology","title":"LIKWID.init_topology_gpu","text":"Initialize LIKWIDs GPU topology module.\n\n\n\n\n\n","category":"method"},{"location":"topo_gpu/#LIKWID.finalize_topology_gpu-Tuple{}","page":"GPU Topology","title":"LIKWID.finalize_topology_gpu","text":"Finalize LIKWIDs GPU topology module.\n\n\n\n\n\n","category":"method"},{"location":"topo_gpu/#LIKWID.get_gpu_topology-Tuple{}","page":"GPU Topology","title":"LIKWID.get_gpu_topology","text":"Get GPU topology\n\n\n\n\n\n","category":"method"},{"location":"topo_gpu/#Types","page":"GPU Topology","title":"Types","text":"","category":"section"},{"location":"topo_gpu/","page":"GPU Topology","title":"GPU Topology","text":"LIKWID.GpuTopology\nLIKWID.GpuDevice","category":"page"},{"location":"topo_gpu/#LIKWID.GpuTopology","page":"GPU Topology","title":"LIKWID.GpuTopology","text":"Topology information of GPUs\n\n\n\n\n\n","category":"type"},{"location":"topo_gpu/#LIKWID.GpuDevice","page":"GPU Topology","title":"LIKWID.GpuDevice","text":"Detailed information about a GPU device\n\n\n\n\n\n","category":"type"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"using LIKWID","category":"page"},{"location":"topo/#CPU-/-NUMA-Topology","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"","category":"section"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"The basis functionality of likwid-topology.","category":"page"},{"location":"topo/#Example","page":"CPU / NUMA Topology","title":"Example","text":"","category":"section"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"Query CPU topology information:","category":"page"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"topo = LIKWID.get_cpu_topology()\ntopo.threadPool\ntopo.cacheLevels","category":"page"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"Get detailed CPU information:","category":"page"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"cpuinfo = LIKWID.get_cpu_info()","category":"page"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"Query information about NUMA nodes:","category":"page"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"numa = LIKWID.get_numa_topology()\nnuma.nodes\nnuma_node = first(numa.nodes)","category":"page"},{"location":"topo/#Graphical-output","page":"CPU / NUMA Topology","title":"Graphical output","text":"","category":"section"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"Currently, LIKWID.jl doesn't feature a native graphical visualization of the CPU topology. However, it provides a small \"wrapper function\" around likwid-topology -g which should give you an output like this:","category":"page"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"LIKWID.print_cpu_topology()","category":"page"},{"location":"topo/#Functions","page":"CPU / NUMA Topology","title":"Functions","text":"","category":"section"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"LIKWID.init_topology()\nLIKWID.finalize_topology()\nLIKWID.get_cpu_topology()\nLIKWID.get_cpu_info()\nLIKWID.print_supported_cpus()\nLIKWID.init_numa()\nLIKWID.finalize_numa()\nLIKWID.get_numa_topology()","category":"page"},{"location":"topo/#LIKWID.init_topology-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.init_topology","text":"Initialize LIKWIDs topology module.\n\n\n\n\n\n","category":"method"},{"location":"topo/#LIKWID.finalize_topology-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.finalize_topology","text":"Close and finalize LIKWIDs topology module.\n\n\n\n\n\n","category":"method"},{"location":"topo/#LIKWID.get_cpu_topology-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.get_cpu_topology","text":"get_cpu_topology() -> CpuTopology\n\nGet the CPU topology of the machine.\n\nAutomatically initializes the topology and NUMA modules, i.e. calls LIKWID.init_topology and LIKWID.init_numa.\n\n\n\n\n\n","category":"method"},{"location":"topo/#LIKWID.get_cpu_info-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.get_cpu_info","text":"get_cpu_info() -> CpuInfo\n\nGet detailed information about the CPU.\n\nAutomatically initializes the topology and NUMA modules, i.e. calls LIKWID.init_topology and LIKWID.init_numa.\n\n\n\n\n\n","category":"method"},{"location":"topo/#LIKWID.print_supported_cpus-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.print_supported_cpus","text":"print_supported_cpus(; cprint=true)\n\nPrint a list of all supported CPUs.\n\nIf cprint=false, LIKWID.jl will first capture the stdout and then print the list.\n\n\n\n\n\n","category":"method"},{"location":"topo/#LIKWID.init_numa-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.init_numa","text":"Initialize LIKWIDs NUMA module.\n\n\n\n\n\n","category":"method"},{"location":"topo/#LIKWID.finalize_numa-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.finalize_numa","text":"Close and finalize LIKWIDs NUMA module.\n\n\n\n\n\n","category":"method"},{"location":"topo/#LIKWID.get_numa_topology-Tuple{}","page":"CPU / NUMA Topology","title":"LIKWID.get_numa_topology","text":"get_numa_topology() -> NumaTopology\n\nGet the NUMA topology of the machine.\n\nAutomatically initializes the topology, NUMA, and affinity modules, i.e. calls LIKWID.init_topology, LIKWID.init_numa, and LIKWID.init_affinity.\n\n\n\n\n\n","category":"method"},{"location":"topo/#Types","page":"CPU / NUMA Topology","title":"Types","text":"","category":"section"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"LIKWID.CpuTopology\nLIKWID.CpuInfo\nLIKWID.HWThread\nLIKWID.CacheLevel\nLIKWID.NumaTopology\nLIKWID.NumaNode","category":"page"},{"location":"topo/#LIKWID.CpuTopology","page":"CPU / NUMA Topology","title":"LIKWID.CpuTopology","text":"CPU topology information\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.CpuInfo","page":"CPU / NUMA Topology","title":"LIKWID.CpuInfo","text":"CPU information\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.HWThread","page":"CPU / NUMA Topology","title":"LIKWID.HWThread","text":"Information about a hardware thread\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.CacheLevel","page":"CPU / NUMA Topology","title":"LIKWID.CacheLevel","text":"Information about a cache level\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.NumaTopology","page":"CPU / NUMA Topology","title":"LIKWID.NumaTopology","text":"CPU topology information\n\n\n\n\n\n","category":"type"},{"location":"topo/#LIKWID.NumaNode","page":"CPU / NUMA Topology","title":"LIKWID.NumaNode","text":"Information about a NUMA node\n\n\n\n\n\n","category":"type"},{"location":"topo/#Supported-CPUs","page":"CPU / NUMA Topology","title":"Supported CPUs","text":"","category":"section"},{"location":"topo/","page":"CPU / NUMA Topology","title":"CPU / NUMA Topology","text":"LIKWID.print_supported_cpus()\nLIKWID.print_supported_cpus(; cprint=false) # hide","category":"page"},{"location":"temperature/","page":"CPU temperature","title":"CPU temperature","text":"using LIKWID","category":"page"},{"location":"temperature/#CPU-Temperature","page":"CPU temperature","title":"CPU Temperature","text":"","category":"section"},{"location":"temperature/#Functions","page":"CPU temperature","title":"Functions","text":"","category":"section"},{"location":"temperature/","page":"CPU temperature","title":"CPU temperature","text":"LIKWID.init_thermal\nLIKWID.get_temperature","category":"page"},{"location":"temperature/#LIKWID.init_thermal","page":"CPU temperature","title":"LIKWID.init_thermal","text":"Initialize thermal measurements on the given CPU.\n\n\n\n\n\n","category":"function"},{"location":"temperature/#LIKWID.get_temperature","page":"CPU temperature","title":"LIKWID.get_temperature","text":"Read the current temperature of the given CPU in degrees Celsius.\n\n\n\n\n\n","category":"function"},{"location":"marker/#Marker-API-(CPU)","page":"CPU","title":"Marker API (CPU)","text":"","category":"section"},{"location":"marker/#Example","page":"CPU","title":"Example","text":"","category":"section"},{"location":"marker/","page":"CPU","title":"CPU","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/perfctr.)","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"# perfctr.jl\nusing LIKWID\nusing LinearAlgebra\n\nLIKWID.Marker.init()\n\nA = rand(128, 64)\nB = rand(64, 128)\nC = zeros(128, 128)\n\nLIKWID.Marker.startregion(\"matmul\")\nfor _ in 1:100\n    mul!(C, A, B)\nend\nLIKWID.Marker.stopregion(\"matmul\")\n\nLIKWID.Marker.close()","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"Running this file with the command likwid-perfctr -C 0 -g FLOPS_DP -m julia perfctr.jl one should obtain something like the following:","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6246 CPU @ 3.30GHz\nCPU type:\tIntel Cascadelake SP processor\nCPU clock:\t3.30 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion matmul, Group 1: FLOPS_DP\n+-------------------+------------+\n|    Region Info    | HWThread 0 |\n+-------------------+------------+\n| RDTSC Runtime [s] |   0.621329 |\n|     call count    |          1 |\n+-------------------+------------+\n+------------------------------------------+---------+------------+\n|                   Event                  | Counter | HWThread 0 |\n+------------------------------------------+---------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  | 4151839000 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  | 2548859000 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  | 2004161000 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_DOUBLE |   PMC0  |          0 |\n|    FP_ARITH_INST_RETIRED_SCALAR_DOUBLE   |   PMC1  |       1572 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_DOUBLE |   PMC2  |          0 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_DOUBLE |   PMC3  |   26624000 |\n+------------------------------------------+---------+------------+\n+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.6213 |\n| Runtime unhalted [s] |     0.7724 |\n|      Clock [MHz]     |  4196.5492 |\n|          CPI         |     0.6139 |\n|     DP [MFLOP/s]     |   342.8031 |\n|   AVX DP [MFLOP/s]   |   342.8006 |\n|  AVX512 DP [MFLOP/s] |   342.8006 |\n|   Packed [MUOPS/s]   |    42.8501 |\n|   Scalar [MUOPS/s]   |     0.0025 |\n|  Vectorization ratio |    99.9941 |\n+----------------------+------------+","category":"page"},{"location":"marker/#Convenience-macro","page":"CPU","title":"Convenience macro","text":"","category":"section"},{"location":"marker/","page":"CPU","title":"CPU","text":"We provide (and export) the macro @region which can be used to write regions like","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"LIKWID.Marker.startregion(\"matmul\")\nfor _ in 1:100\n    mul!(C, A, B)\nend\nLIKWID.Marker.stopregion(\"matmul\")","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"simply as","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"@region \"matmul\" for _ in 1:100\n    mul!(C, A, B)\nend","category":"page"},{"location":"marker/#SIMD-/-AVX","page":"CPU","title":"SIMD / AVX","text":"","category":"section"},{"location":"marker/","page":"CPU","title":"CPU","text":"Let's run the same example on a Rocketlacke processor. We might get the following.","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"--------------------------------------------------------------------------------\nCPU name:\t11th Gen Intel(R) Core(TM) i7-11700K @ 3.60GHz\nCPU type:\tIntel Rocketlake processor\nCPU clock:\t3.60 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion matmul, Group 1: FLOPS_DP\n+-------------------+------------+\n|    Region Info    | HWThread 0 |\n+-------------------+------------+\n| RDTSC Runtime [s] |   0.465348 |\n|     call count    |          1 |\n+-------------------+------------+\n\n+------------------------------------------+---------+------------+\n|                   Event                  | Counter | HWThread 0 |\n+------------------------------------------+---------+------------+\n|             INSTR_RETIRED_ANY            |  FIXC0  | 4414042000 |\n|           CPU_CLK_UNHALTED_CORE          |  FIXC1  | 2237935000 |\n|           CPU_CLK_UNHALTED_REF           |  FIXC2  | 1648606000 |\n| FP_ARITH_INST_RETIRED_128B_PACKED_DOUBLE |   PMC0  |  106496000 |\n|    FP_ARITH_INST_RETIRED_SCALAR_DOUBLE   |   PMC1  |        569 |\n| FP_ARITH_INST_RETIRED_256B_PACKED_DOUBLE |   PMC2  |          0 |\n| FP_ARITH_INST_RETIRED_512B_PACKED_DOUBLE |   PMC3  |          0 |\n+------------------------------------------+---------+------------+\n\n+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.4653 |\n| Runtime unhalted [s] |     0.6217 |\n|      Clock [MHz]     |  4886.7513 |\n|          CPI         |     0.5070 |\n|     DP [MFLOP/s]     |   457.7061 |\n|   AVX DP [MFLOP/s]   |          0 |\n|  AVX512 DP [MFLOP/s] |          0 |\n|   Packed [MUOPS/s]   |   228.8524 |\n|   Scalar [MUOPS/s]   |     0.0012 |\n|  Vectorization ratio |    99.9995 |\n+----------------------+------------+","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"Given the absence of AVX calls, it seems like OpenBLAS is falling back to a suboptimal Nehalem kernel. If we install MKL.jl and add using MKL to the top of our script above, the metrics table becomes","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"+----------------------+------------+\n|        Metric        | HWThread 0 |\n+----------------------+------------+\n|  Runtime (RDTSC) [s] |     0.4599 |\n| Runtime unhalted [s] |     0.6065 |\n|      Clock [MHz]     |  4888.9102 |\n|          CPI         |     0.5145 |\n|     DP [MFLOP/s]     |   459.6089 |\n|   AVX DP [MFLOP/s]   |   459.6080 |\n|  AVX512 DP [MFLOP/s] |   459.6080 |\n|   Packed [MUOPS/s]   |    57.4510 |\n|   Scalar [MUOPS/s]   |     0.0008 |\n|  Vectorization ratio |    99.9986 |\n+----------------------+------------+","category":"page"},{"location":"marker/#likwid-perfctr-in-a-nutshell","page":"CPU","title":"likwid-perfctr in a nutshell","text":"","category":"section"},{"location":"marker/","page":"CPU","title":"CPU","text":"Most importantly, you need to use the -m option to activate the marker API.","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"To list the available performance groups, run likwid-perfctr -a:","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"PerfMon group name\tDescription\n--------------------------------------------------------------------------------\n        MEM_SP\tOverview of arithmetic and main memory performance\nCYCLE_ACTIVITY\tCycle Activities\n        ENERGY\tPower and Energy consumption\n   UOPS_RETIRE\tUOPs retirement\n           PMM\tIntel Optane DC bandwidth in MBytes/s\n     TLB_INSTR\tL1 Instruction TLB miss rate/ratio\n          DATA\tLoad to store ratio\n    UOPS_ISSUE\tUOPs issueing\n       L2CACHE\tL2 cache miss rate/ratio\n            L2\tL2 cache bandwidth in MBytes/s\n     FLOPS_AVX\tPacked AVX MFLOP/s\n           MEM\tMain memory bandwidth in MBytes/s\n        BRANCH\tBranch prediction miss rate/ratio\n      FLOPS_SP\tSingle Precision MFLOP/s\n        MEM_DP\tOverview of arithmetic and main memory performance\n       L3CACHE\tL3 cache miss rate/ratio\n           UPI\tUPI data traffic\n     UOPS_EXEC\tUOPs execution\n      TLB_DATA\tL2 data TLB miss rate/ratio\n        CACHES\tCache bandwidth in MBytes/s\n        DIVIDE\tDivide unit information\n           TMA\tTop down cycle allocation\n         CLOCK\tPower and Energy consumption\n      FLOPS_DP\tDouble Precision MFLOP/s\n  CYCLE_STALLS\tCycle Activities (Stalls)\n            L3\tL3 cache bandwidth in MBytes/s\n           UPI\tUPI traffic\n         L3NEW\tL3 cache bandwidth in MBytes/s\n          L3PF\tL3 cache bandwidth in MBytes/s\n          L2L3\tL3 cache bandwidth in MBytes/s","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"These groups can be passed to the command line option -g. Note that you can also query the available performance groups programmatically using LIKWID.PerfMon.get_groups().","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"Another important option is -C <list>:","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"Processor ids to pin threads and measure, e.g. 1,2-4,8. For information about the <list> syntax, see likwid-pin.","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"Note that cpu ids start with zero (not one).","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"Combinding the points above, the full command could look like this: likwid-perfctr -C 0 -g FLOPS_DP -m julia.","category":"page"},{"location":"marker/","page":"CPU","title":"CPU","text":"For more information, check out the official documentation.","category":"page"},{"location":"marker/#Functions","page":"CPU","title":"Functions","text":"","category":"section"},{"location":"marker/","page":"CPU","title":"CPU","text":"Modules = [LIKWID.Marker]","category":"page"},{"location":"marker/#LIKWID.Marker.close-Tuple{}","page":"CPU","title":"LIKWID.Marker.close","text":"Close the connection to the LIKWID Marker API and write out measurement data to file. This file will be evaluated by likwid-perfctr.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.getregion-Tuple{AbstractString}","page":"CPU","title":"LIKWID.Marker.getregion","text":"getregion(regiontag::AbstractString) -> nevents, events, time, count\n\nGet the intermediate results of the region identified by regiontag. On success, it returns     * nevents: the number of events in the current group,     * events: a list with all the aggregated event results,     * time: the measurement time for the region and     * count: the number of calls.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.init-Tuple{}","page":"CPU","title":"LIKWID.Marker.init","text":"Initialize the Marker API. Must be called previous to all other functions.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.init_nothreads-Tuple{}","page":"CPU","title":"LIKWID.Marker.init_nothreads","text":"Initialize the Marker API only on the main thread. LIKWID.Marker.threadinit() must be called manually.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.isactive-Tuple{}","page":"CPU","title":"LIKWID.Marker.isactive","text":"Checks whether the Marker API is active, i.e. julia has been started under likwid-perfctr -C ... -g ... -m.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.nextgroup-Tuple{}","page":"CPU","title":"LIKWID.Marker.nextgroup","text":"Switch to the next event set in a round-robin fashion. If you have set only one event set on the command line, this function performs no operation.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.region-Tuple{Any, AbstractString}","page":"CPU","title":"LIKWID.Marker.region","text":"region(f, regiontag::AbstractString)\n\nAdds a LIKWID marker region around the execution of the given function f using Marker.startregion, Marker.stopregion under the hood. Note that LIKWID.Marker.init() and LIKWID.Marker.close() must be called before and after, respectively.\n\nExamples\n\njulia> using LIKWID\n\njulia> LIKWID.Marker.init()\n\njulia> region(\"sleeping...\") do\n           sleep(1)\n       end\ntrue\n\njulia> region(()->rand(100), \"create rand vec\")\ntrue\n\njulia> LIKWID.Marker.close()\n\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.registerregion-Tuple{AbstractString}","page":"CPU","title":"LIKWID.Marker.registerregion","text":"Register a region with name regiontag to the Marker API. On success, true is returned.\n\nThis is an optional function to reduce the overhead of region registration at Marker.startregion. If you don't call registerregion, the registration is done at startregion.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.resetregion-Tuple{AbstractString}","page":"CPU","title":"LIKWID.Marker.resetregion","text":"Reset the values stored using the region name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.startregion-Tuple{AbstractString}","page":"CPU","title":"LIKWID.Marker.startregion","text":"Start measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.stopregion-Tuple{AbstractString}","page":"CPU","title":"LIKWID.Marker.stopregion","text":"Stop measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.threadinit-Tuple{}","page":"CPU","title":"LIKWID.Marker.threadinit","text":"Add the current thread to the Marker API.\n\n\n\n\n\n","category":"method"},{"location":"marker/#LIKWID.Marker.@region-Tuple{Any, Any}","page":"CPU","title":"LIKWID.Marker.@region","text":"Convenience macro for Marker.region.\n\nExamples\n\njulia> using LIKWID\n\njulia> LIKWID.Marker.init()\n\njulia> @region \"sleeping...\" sleep(1)\ntrue\n\njulia> @region \"create rand vec\" rand(100)\ntrue\n\njulia> LIKWID.Marker.close()\n\n\n\n\n\n\n","category":"macro"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"using LIKWID","category":"page"},{"location":"likwid-pin/#likwid-pin","page":"likwid-pin","title":"likwid-pin","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"Pinning threads to cores. For details, check out the official documentation.","category":"page"},{"location":"likwid-pin/#Example","page":"likwid-pin","title":"Example","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/pin.)","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"# pin.jl\nusing Base.Threads\n\nglibc_coreid() = @ccall sched_getcpu()::Cint\n\n@threads for i in 1:nthreads()\n    println(\"Thread: $(i), CPU: $(glibc_coreid())\")\nend","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"Running this file with e.g. likwid-pin -s 0xffffffffffffffe1 -c 1,3,5,7 julia -t 4 pin.jl one obtains","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"[pthread wrapper] \n[pthread wrapper] MAIN -> 1\n[pthread wrapper] PIN_MASK: 0->3  1->5  2->7  \n[pthread wrapper] SKIP MASK: 0xFFFFFFFFFFFFFFE1\n\tthreadid 140576878921280 -> SKIP \n\tthreadid 140576612378176 -> hwthread 3 - OK\n\tthreadid 140576590759488 -> hwthread 5 - OK\n\tthreadid 140576494188096 -> hwthread 7 - OK\nThread: 1, CPU: 1\nThread: 2, CPU: 3\nThread: 3, CPU: 5\nThread: 4, CPU: 7","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"If you're wondering about the -s 0xffffffffffffffe1 option, see Mask below.","category":"page"},{"location":"likwid-pin/#Mask","page":"likwid-pin","title":"Mask","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"(See this discussion on the Julia discourse.)","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"In general, likwid-pin pins all pthread-threads. However, julia involves more than the \"Julia user threads\" specified via the -t option. For example, it create an additional unix signal thread (in src/signals-unix.c) and - unless OPENBLAS_NUM_THREADS=1 - the OpenBLAS related threads (blas_thread_init () in [..]/lib/julia/libopenblas64_.so). Hence, when you run likwid-pin -c 0-3 julia -t 4 the four cores (0-3) are actually oversubscribed and multiple \"Julia user threads\" get pinned to the same core.","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"To work around this, we need to provide a mask to likwid-pin via the -s option. To compute an appropriate mask for N \"Julia user threads\" you may use the helper function LIKWID.pin_mask(N):","category":"page"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"LIKWID.pin_mask(4)","category":"page"},{"location":"likwid-pin/#Functions","page":"likwid-pin","title":"Functions","text":"","category":"section"},{"location":"likwid-pin/","page":"likwid-pin","title":"likwid-pin","text":"LIKWID.pin_mask","category":"page"},{"location":"likwid-pin/#LIKWID.pin_mask","page":"likwid-pin","title":"LIKWID.pin_mask","text":"pin_mask(N::Integer) -> mask\n\nGenerates a mask that can be supplied to likwid pin -s <mask> to pin N Julia threads.\n\nTaken from https://discourse.julialang.org/t/thread-affinitization-pinning-julia-threads-to-cores/58069/8.\n\n\n\n\n\n","category":"function"},{"location":"marker_gpu/#Marker-API-(GPU)","page":"GPU","title":"Marker API (GPU)","text":"","category":"section"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"Note: This is a maturing feature. Only NVIDIA GPUs are supported.","category":"page"},{"location":"marker_gpu/#Example","page":"GPU","title":"Example","text":"","category":"section"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"(See https://github.com/JuliaPerf/LIKWID.jl/tree/main/examples/perfctr_gpu.)","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"# perfctr_gpu.jl\nusing LIKWID\nusing LinearAlgebra\nusing CUDA\n\n@assert CUDA.functional()\n\nLIKWID.GPUMarker.init()\n\n# Note: CUDA defaults to Float32\nAgpu = CUDA.rand(128, 64)\nBgpu = CUDA.rand(64, 128)\nCgpu = CUDA.zeros(128, 128)\n\nLIKWID.GPUMarker.startregion(\"matmul\")\nfor _ in 1:100\n    mul!(Cgpu, Agpu, Bgpu)\nend\nLIKWID.GPUMarker.stopregion(\"matmul\")\n\nLIKWID.GPUMarker.close()","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"Running this file with the command likwid-perfctr -G 0 -W FLOPS_SP -m julia perfctr_gpu.jl one should obtain something like the following:","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"--------------------------------------------------------------------------------\nCPU name:\tIntel(R) Xeon(R) Gold 6246 CPU @ 3.30GHz\nCPU type:\tIntel Cascadelake SP processor\nCPU clock:\t3.30 GHz\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------\nRegion matmul, Group 1: FLOPS_SP\n+-------------------+----------+\n|    Region Info    |   GPU 0  |\n+-------------------+----------+\n| RDTSC Runtime [s] | 3.426146 |\n|     call count    |        1 |\n+-------------------+----------+\n+----------------------------------------------------+---------+----------+\n|                        Event                       | Counter |   GPU 0  |\n+----------------------------------------------------+---------+----------+\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FADD_PRED_ON_SUM |   GPU0  |  2457600 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FMUL_PRED_ON_SUM |   GPU1  |  3276800 |\n| SMSP_SASS_THREAD_INST_EXECUTED_OP_FFMA_PRED_ON_SUM |   GPU2  | 52436990 |\n+----------------------------------------------------+---------+----------+\n+---------------------+---------+\n|        Metric       |  GPU 0  |\n+---------------------+---------+\n| Runtime (RDTSC) [s] |  3.4261 |\n|     SP [MFLOP/s]    | 32.2836 |\n+---------------------+---------+","category":"page"},{"location":"marker_gpu/#likwid-perfctr-in-a-nutshell","page":"GPU","title":"likwid-perfctr in a nutshell","text":"","category":"section"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"Most importantly, as for CPUs, you need to use the -m option to activate the marker API.","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"To list the available GPU performance groups, run likwid-perfctr -a and look for the lower \"NvMon\" table:","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"[...]\n\nNvMon group name\tDescription\n--------------------------------------------------------------------------------\n    DATA\tLoad to store ratio\nFLOPS_SP\tSingle-precision floating point\nFLOPS_HP\tHalf-precision floating point\nFLOPS_DP\tDouble-precision floating point","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"These groups can be passed to the command line option -W. Note that you can also query the available GPU performance groups programmatically using LIKWID.NvMon.get_groups(gpuid::Integer).","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"Another important option is -G <list>, where <list> is a list of GPUs to monitor. Note that GPU ids start with zero (not one).","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"Combinding the points above, the full command could look like this: likwid-perfctr -G 0 -W FLOPS_SP -m julia.","category":"page"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"For more information, check out the official documentation.","category":"page"},{"location":"marker_gpu/#Functions","page":"GPU","title":"Functions","text":"","category":"section"},{"location":"marker_gpu/","page":"GPU","title":"GPU","text":"Modules = [LIKWID.GPUMarker]","category":"page"},{"location":"marker_gpu/#LIKWID.GPUMarker.close-Tuple{}","page":"GPU","title":"LIKWID.GPUMarker.close","text":"Close the connection to the LIKWID GPU Marker API and write out measurement data to file. This file will be evaluated by likwid-perfctr.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.getregion-Tuple{AbstractString}","page":"GPU","title":"LIKWID.GPUMarker.getregion","text":"getregion(regiontag::AbstractString) -> nevents, events, time, count\n\nGet the intermediate results of the region identified by regiontag. On success, it returns     * nevents: the number of events in the current group,     * events: a list with all the aggregated event results,     * time: the measurement time for the region and     * count: the number of calls.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.init-Tuple{}","page":"GPU","title":"LIKWID.GPUMarker.init","text":"Initialize the NvMon Marker API of the LIKWID library. Must be called previous to all other functions.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.isactive-Tuple{}","page":"GPU","title":"LIKWID.GPUMarker.isactive","text":"Checks whether the NVIDIA GPU Marker API is active, i.e. julia has been started under likwid-perfctr -G ... -W ... -m.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.nextgroup-Tuple{}","page":"GPU","title":"LIKWID.GPUMarker.nextgroup","text":"Switch to the next event set in a round-robin fashion. If you have set only one event set on the command line, this function performs no operation.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.registerregion-Tuple{AbstractString}","page":"GPU","title":"LIKWID.GPUMarker.registerregion","text":"Register a region with name regiontag to the GPU Marker API. On success, true is returned.\n\nThis is an optional function to reduce the overhead of region registration at Marker.startregion. If you don't call registerregion, the registration is done at startregion.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.resetregion-Tuple{AbstractString}","page":"GPU","title":"LIKWID.GPUMarker.resetregion","text":"Reset the values stored using the region name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.startregion-Tuple{AbstractString}","page":"GPU","title":"LIKWID.GPUMarker.startregion","text":"Start measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"marker_gpu/#LIKWID.GPUMarker.stopregion-Tuple{AbstractString}","page":"GPU","title":"LIKWID.GPUMarker.stopregion","text":"Stop measurements under the name regiontag. On success, true is returned.\n\n\n\n\n\n","category":"method"},{"location":"#LIKWID-Like-I-Knew-What-I'm-Doing","page":"LIKWID","title":"LIKWID - Like I Knew What I'm Doing","text":"","category":"section"},{"location":"","page":"LIKWID","title":"LIKWID","text":"LIKWID.jl is a Julia wrapper for the performance monitoring and benchmarking suite LIKWID.","category":"page"},{"location":"#Installation","page":"LIKWID","title":"Installation","text":"","category":"section"},{"location":"","page":"LIKWID","title":"LIKWID","text":"Prerequisites:","category":"page"},{"location":"","page":"LIKWID","title":"LIKWID","text":"You must have likwid installed (see the build & install instructions).\nYou must be running Linux. (LIKWID doesn't support macOS or Windows.)","category":"page"},{"location":"","page":"LIKWID","title":"LIKWID","text":"LIKWID.jl is a registered Julia package. Hence, you can simply add it to your Julia environment with the command","category":"page"},{"location":"","page":"LIKWID","title":"LIKWID","text":"] add LIKWID","category":"page"},{"location":"nvmon/#NVIDIA-Monitoring-(NvMon)","page":"NVIDIA monitoring","title":"NVIDIA Monitoring (NvMon)","text":"","category":"section"},{"location":"nvmon/","page":"NVIDIA monitoring","title":"NVIDIA monitoring","text":"Note: This is a maturing feature. Only NVIDIA GPUs are supported.","category":"page"},{"location":"nvmon/#Functions","page":"NVIDIA monitoring","title":"Functions","text":"","category":"section"},{"location":"nvmon/","page":"NVIDIA monitoring","title":"NVIDIA monitoring","text":"Modules = [LIKWID.NvMon]","category":"page"},{"location":"nvmon/#LIKWID.NvMon.add_event_set-Tuple{AbstractString}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.add_event_set","text":"add_event_set(estr) -> groupid\n\nAdd a performance group or a custom event set to the nvmon module. Returns a groupid which is required to later specify the event set.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_groups","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_groups","text":"Return a list of all available nvmon groups for the GPU identified by gpuid.\n\nExamples\n\njulia> LIKWID.NvMon.get_groups()\n4-element Vector{LIKWID.GroupInfoCompact}:\n DATA => Load to store ratio\n FLOPS_SP => Single-precision floating point\n FLOPS_HP => Half-precision floating point\n FLOPS_DP => Double-precision floating point\n\n\n\n\n\n","category":"function"},{"location":"nvmon/#LIKWID.NvMon.get_id_of_active_group-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_id_of_active_group","text":"Return the groupid of the currently activate group.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_last_metric-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_last_metric","text":"Return the derived metric result of the last measurement cycle identified by group groupid and the indices for metric metricidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_last_result-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_last_result","text":"Return the raw counter register result of the last measurement cycle identified by group groupid and the indices for event eventidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_longinfo_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_longinfo_of_group","text":"Return the (long) description of a performance group.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_metric-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_metric","text":"Return the derived metric result of all measurements identified by group groupid and the indices for metric metricidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_counter-Tuple{Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_counter","text":"Return the name of the counter register identified by groupid and eventidx.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_event-Tuple{Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_event","text":"Return the name of the event identified by groupid and eventidx.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_group","text":"Return the name of the group identified by groupid. If it is a custom event set, the name is set to Custom.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_name_of_metric-Tuple{Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_name_of_metric","text":"Return the name of a derived metric identified by groupid and metricidx.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_events-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_events","text":"Return the number of events in the group.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_gpus-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_gpus","text":"Return the number of GPUs initialized in the nvmon module.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_groups-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_groups","text":"Return the number of groups currently registered in the nvmon module.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_number_of_metrics-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_number_of_metrics","text":"Return the number of metrics in the group. Always zero for custom event sets.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_result-Tuple{Integer, Integer, Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_result","text":"Return the raw counter register result of all measurements identified by group groupid and the indices for event eventidx and thread threadidx.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_shortinfo_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_shortinfo_of_group","text":"Return the short information about a performance group.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.get_time_of_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.get_time_of_group","text":"Return the measurement time for group identified by groupid.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.read_counters-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.read_counters","text":"Read the counter registers. To be executed after start_counters and before stop_counters. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.setup_counters-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.setup_counters","text":"Program the counter registers to measure all events in group groupid. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.start_counters-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.start_counters","text":"Start the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.stop_counters-Tuple{}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.stop_counters","text":"Stop the counter registers. Returns true on success.\n\n\n\n\n\n","category":"method"},{"location":"nvmon/#LIKWID.NvMon.switch_group-Tuple{Integer}","page":"NVIDIA monitoring","title":"LIKWID.NvMon.switch_group","text":"Switch currently active group to groupid. Returns true on success.\n\n\n\n\n\n","category":"method"}]
}
